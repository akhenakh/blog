<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geo &middot; Fabrice Aneche</title>

    <meta name="description" content="">

    <meta name="generator" content="Hugo 0.33" />
    <meta name="twitter:card" content="summary">
    
    <meta name="twitter:title" content="Geo &middot; Fabrice Aneche">
    <meta name="twitter:description" content="">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Geo &middot; Fabrice Aneche">
    <meta property="og:description" content="">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="https://blog.nobugware.com/css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="Fabrice Aneche" href="https://blog.nobugware.com/index.xml" />
    <link href="https://blog.nobugware.com/css/prism.css" rel="stylesheet" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="https://blog.nobugware.com">Fabrice Aneche</a></h1>
            <h2 class="brand-tagline"></h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="http://www.nobugware.com"><i class="fa fa-building-o"></i> Hiring</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/akhenakh"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/akhenakh "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="https://blog.nobugware.com/index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">01 Aug 2018, 00:19</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.nobugware.com/post/2018/my_own_car_system_raspberry_pi_offline_mapping_map_matching_places_part2/" class="post-title">My Own Car System, Rear Camera, Offline Maps &amp; Routing, Map Matching with Go on Raspberry Pi part II</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Geo" href="https://blog.nobugware.com/categories/geo">Geo</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<p>This is my journey building an open source car system with Go &amp; Qt, rear camera, live OpenGL map &hellip;</p>

<h2 id="cross-compilation">Cross compilation</h2>

<p><a href="https://blog.nobugware.com/post/2018/my_own_car_system_raspberry_pi_offline_mapping/">In Part I</a>, I had to patch qtmultimedia for the camera to work, but Qt compilation is resource hungry, same goes for the osrm compilation, the memory of the Raspberry Pi is too small.</p>

<p>I had to to set up a <a href="https://wiki.archlinux.org/index.php/Distcc#Arch_Linux_ARM">cross compilation system</a> in my case for armv7h.</p>

<h2 id="qml-development">QML Development</h2>

<p>Since most of the application is in <a href="https://en.wikipedia.org/wiki/QML">QML</a>, I&rsquo;ve used the c++ <code>main.cpp</code> launcher as long as possible for the development.<br />
At the moment I needed to inject data from the outside world (like the GPS location) to QML via Qt, so I switched to Go using <a href="https://github.com/therecipe/qt">therecipe Qt Go bindings</a>.</p>

<p>The Go bindings project is young but the main author is really active fixing issues.</p>

<p>It makes desktop applications easy to code without the assle of C++ (at least for me).</p>

<p>About QML, by separating the logic and forms using <code>.qml.ui</code> you still can edit your views with <a href="https://wiki.qt.io/Qt_Creator">Qt Creator</a>:<br />
That&rsquo;s just the narrative, truth is Creator is really buggy and I edited the ui files by hand most of the time.<br />
I worked with Interface Builder on iOS for years, Qt is painful, lack of decent visual editor for QML really hurts.</p>

<h2 id="serving-the-map-without-internet-access">Serving the map without internet access</h2>

<p><a href="https://blog.nobugware.com/post/2018/my_own_car_system_raspberry_pi_offline_mapping/">In Part I</a>, we talked about OpenMapTiles and OpenGL rendering, but I needed a web server capable of reading MBTiles format and serving the necessary assets for the map to be rendered.</p>

<p>I&rsquo;ve created <a href="https://github.com/akhenakh/mbmatch">mbmatch</a> in Go for that purpose so <a href="https://github.com/akhenakh/mocs">mocs</a> can render the map without Internet access, it will also map match the positions in the future.</p>

<h2 id="experimenting-with-another-touch-screen">Experimenting with another touch screen</h2>

<p>I&rsquo;m using a less performant but smaller <a href="https://www.amazon.ca/gp/product/B01I9DS2G8">LANDZO 5 Inch Touch Display</a> 800x480<br />
This touchscreen is handled as a one button mouse.</p>

<p>It can be calibrate using <a href="https://github.com/kergoth/tslib/">tslib</a> <code>ts_calibrate</code> command.</p>

<p>Then in your start env tell Qt to use tslib.</p>

<pre><code>TSLIB_TSDEVICE=/dev/input/event0
QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
QT_QPA_FB_TSLIB=1
</code></pre>

<h2 id="gps">GPS</h2>

<p>Like I said in <a href="https://blog.nobugware.com/post/2018/my_own_car_system_raspberry_pi_offline_mapping/">part I</a>, the Linux gps daemons are using obscure and over complicated protocols so <a href="https://xkcd.com/927/">I&rsquo;ve decided</a> to write my own gps daemon in Go using a gRPC stream interface. You can <a href="https://github.com/akhenakh/gpsd">find it here</a>.</p>

<p>I&rsquo;m also not satisfied with the map matching of OSRM for real time display, I may rewrite one using <a href="https://github.com/akhenakh/mbmatch">mbmatch</a>.</p>

<h2 id="pois">POIs</h2>

<p>I&rsquo;ve started POIs lookups with full text search and geo proximity using <a href="http://github.com/blevesearch/bleve">bleve</a> by exposing an API compatible with the OSM API so it can be used directly by QML Locations.</p>

<h2 id="night-map">Night Map</h2>

<p>I&rsquo;m a huge fan of the <a href="https://github.com/altercation/solarized">Solarized colors</a>, I&rsquo;ve made a style for the map you can find it <a href="https://github.com/akhenakh/mocs/blob/master/external/solarized-dark.style">here</a></p>

<p><img src="https://blog.nobugware.com/img/mocssolarized.jpg" alt="Solarized" /></p>

<h2 id="speeding-up-boot">Speeding up boot</h2>

<pre><code>systemctl mask systemd-udev-settle.service
systemctl mask lvm2-activation-net.service
systemctl mask lvm2-monitor.service
</code></pre>

<h2 id="status">Status</h2>

<p>The project is far from finished and not ready for everybody but it&rsquo;s fun to play with.</p>

<p>I&rsquo;ve <a href="https://github.com/akhenakh/mocs">open sourced most of the code for Mocs on github</a>, feel free to contribute.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">10 Jun 2018, 09:19</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.nobugware.com/post/2018/my_own_car_system_raspberry_pi_offline_mapping/" class="post-title">My Own Car System, Rear Camera, Offline Maps &amp; Routing on Raspberry Pi part I</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Geo" href="https://blog.nobugware.com/categories/geo">Geo</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<p>At first I needed a car rear camera, one thing led to another&hellip;</p>

<p>My Car, from 2011, only has an LCD display and no rear camera, so I bought a <a href="https://www.amazon.ca/gp/product/B06ZY949CF">PAL rear camera</a>, we passed some cables from the rear window to the front then everything begun.<br />
Here is my journey to transform my car into a modern system running on RPi3 (a never ending project).</p>

<h2 id="hardware">Hardware</h2>

<p>I&rsquo;m using an Rpi3 (old model).</p>

<p>With <a href="https://archlinuxarm.org">Arch for ARM</a> but any system will do.</p>

<p>The screen is an <a href="https://www.amazon.ca/gp/product/B019K6CRVY/ref=oh_aui_search_detailpage?ie=UTF8&amp;psc=1">Eleduino Raspberry Pi 7 Inch 1024x600 Pixel IPS Hdmi Input Capacitive Touch Screen Display</a><br />
An <a href="https://www.ebay.ca/itm/USB-2-0-Easycap-Video-With-Audio-VHS-DC60-to-DVD-Converter-Capture-Card-Adapter-/142504839503?hash=item212df3494f&amp;_uhb=1">USB 2.0 EasyCap</a> to retrieve the composite signal.</p>

<p>No driver needed for both the screen and the video capture dongle.</p>

<pre><code>mplayer tv:// -tv driver=v4l2:device=/dev/video0:fps=25:outfmt=yuy2:norm=PAL
</code></pre>

<p><img src="https://blog.nobugware.com/img/rearcam.jpg" alt="Camera" /><br />
mplayer is working out of the box, so I thought everything was okay with the camera, so I thought.</p>

<p>I needed a GUI to display the camera and the date (at this this time this project was just a rear camera display).<br />
So I choose <a href="https://github.com/therecipe/qt">Qt &amp; Golang</a>, not the normal contenders but I can&rsquo;t handle C++ and had experiences with QtGo, and modern Qt apps are just QML code anyway&hellip; So I thought&hellip;</p>

<p>I&rsquo;ve started to code a small QML app but when displaying the video I got:</p>

<pre><code>ERROR: from element /GstPipeline:pipeline0/GstV4l2Src:v4l2src0: Device '/dev/video0' does not support progressive interlacing
Additional debug info:
gstv4l2object.c(3768): gst_v4l2_object_set_format_full (): /GstPipeline:pipeline0/GstV4l2Src:v4l2src0:
Device wants interleaved interlacing
</code></pre>

<p>Qt via Gstreamer does not allow non interlaced videos :(<br />
One solution is to force a pipeline with an interlacer.</p>

<p>Easy on the command line
<code>gst-launch-1.0 v4l2src  ! interlace ! xvimagesink</code></p>

<p>Not that easy via Qt I had to patch the Qt Gstreamer plugin <code>camerabinsession.cpp</code> to insert a filter on the preview:
at the end of <code>GstElement *CameraBinSession::buildCameraSource()</code></p>

<pre><code class="language-c++">    const QByteArray envInterlace = qgetenv(&quot;QT_GSTREAMER_CAMERABIN_VIDEO_INTERLACE&quot;);
    if (envInterlace.length() &gt; 0) {
        GstElement *interlace = gst_element_factory_make (&quot;interlace&quot;, NULL);
        if (interlace == NULL)
            g_error (&quot;Could not create 'interlace' element&quot;);


        g_object_set(G_OBJECT(m_camerabin), &quot;viewfinder-filter&quot;, interlace, NULL);

        #if CAMERABIN_DEBUG
            qDebug() &lt;&lt; &quot;set camera filter&quot; &lt;&lt; interlace;
        #endif
        gst_object_unref (interlace);
    }
</code></pre>

<h2 id="gps">GPS</h2>

<p>I had a serial GPS around, why not display a moving map?</p>

<p>Enable serial port in <code>/boot/config.txt</code> (note Bluetooth must be disabled &hellip;)</p>

<pre><code>enable_uart=1
dtoverlay=pi3-disable-bt
</code></pre>

<p>pin 8  TXD<br />
pin 10 RXD</p>

<p>remove <code>console=ttyAMA0,115200</code> and <code>kgdboc=ttyAMA0,115200</code> from <code>/boot/cmdline.txt</code></p>

<p>I thought it would be very easy to read NMEA via serial.<br />
It was, gpsd worked in seconds but &hellip; it seems we can&rsquo;t disable the auto speed, equal 4s lost at start.<br />
Plus Qt is using libgeoclue or Gypsy which <a href="https://gypsy.freedesktop.org/why-not-gpsd.html">does not want to talk with gpsd</a>.<br />
I tried both of them, they didn&rsquo;t work, it&rsquo;s a mess to debug, documentation is just the API&hellip;</p>

<p>So one thing led to another&hellip; I&rsquo;ve written a very small and simple gpsd in Go with a gRPC interface, so it can be queried from anything.<br />
It&rsquo;s also a bit more advanced since it can map match &amp; route match the positions with OSRM.</p>

<h2 id="offline-maps">Offline maps</h2>

<p><a href="https://openmaptiles.org">OpenMapTiles project is great</a> to generate vectors data in MBTILES format, you can serve them with <a href="https://github.com/akhenakh/mbmatch">mbmatch</a>.<br />
Qt Map QML can display them using the <code>mapboxgl</code> driver, some <a href="https://openmaptiles.org/styles/">free styles</a> are provided.</p>

<p>Here is an example QML Map plugin.</p>

<pre><code class="language-QML">    Plugin {
        id: mapPlugin
        name: &quot;mapboxgl&quot;
        PluginParameter{
            name: &quot;mapboxgl.mapping.additional_style_urls&quot;
            value: &quot;http://localhost:4000/osm-liberty-gl.style&quot;
        }
    }
</code></pre>

<p>Note on X11 and EGL:<br />
Using the mapboxgl renderer under X11 on the Rpi3 is taking a lot of ressources.<br />
Qt5 is <a href="https://doc.qt.io/qt-5/embedded-linux.html">capable of directly talking to the GPU without X11</a>, the performance difference is night and day.</p>

<p>So just run your Qt app without X11 with the following env vars.</p>

<pre><code>QT_QPA_PLATFORM=eglfs:/dev/fb0
QT_QPA_EGLFS_HIDECURSOR=yes
</code></pre>

<h2 id="offline-routing">Offline Routing</h2>

<p>Hopefully the provided Qt <code>osm</code> plugins knows how to route using the <a href="https://github.com/Project-OSRM/osrm-backend/blob/master/docs/http.md">OSRM API</a>.<br />
So you can run a local <a href="https://github.com/Project-OSRM/osrm-backend">OSRM backend</a> for routing and it will just work.</p>

<p>Generate the route indexes.</p>

<pre><code>osrm-extract -p /usr/share/osrm/profiles/car.lua quebec-latest.osm.pbf 
osrm-contract quebec-latest.osrm
osrm-routed quebec-latest.osrm
</code></pre>

<pre><code class="language-QML">    Plugin {
        id: routePlugin
        name: &quot;osm&quot;
        PluginParameter{
            name: &quot;osm.routing.host&quot;
            value: &quot;http://localhost:5000/route/v1/driving/&quot;
        }
    }
</code></pre>

<p><img src="https://blog.nobugware.com/img/mocs.jpg" alt="Mocs" /></p>

<p>The app can display the rear camera and a moving map !!</p>

<p><a href="https://blog.nobugware.com/post/2018/my_own_car_system_raspberry_pi_offline_mapping_map_matching_places_part2/">Part 2</a>  will be about searching places by extracting OSM data and indexing them in a small Go program that can run on the rpi, reading ODB data from the car via Bluetooth, packaging the whole thing and open sourcing some code.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">18 Jan 2018, 08:20</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.nobugware.com/post/2018/google-s2-python-jupyter/" class="post-title">Google S2 with Python &amp; Jupyter</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Geo" href="https://blog.nobugware.com/categories/geo">Geo</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>Google is working again on <a href="https://blog.nobugware.com/post/2016/geo_db_s2_geohash_database/">S2 a spatial library</a> !!!</p>

<p>And they even have created a website to communicate about it <a href="https://s2geometry.io/">s2geometry</a>.</p>

<p>The C++ port contains a <a href="https://github.com/google/s2geometry/tree/master/src/python">Python Swig interface</a>.</p>

<p>I&rsquo;ve been using an unofficial Python port with Jupyter for years now things are way more simpler.</p>

<p>If you are on Arch I&rsquo;ve create a package, simply install <a href="https://aur.archlinux.org/packages/s2geometry-git">AUR s2geometry-git</a></p>

<p>First we want a clean Jupyter install from scratch:</p>

<pre><code>virtualenv3 ~/dev/venv3
source ~/dev/venv3/bin/activate
pip install jupyter
pip install cython
pip install numpy
pip install matplotlib scikit-learn scipy Shapely folium geojson Cartopy
cp /usr/lib/python3.6/site-packages/_pywraps2.so $VIRTUAL_ENV/lib/python3.6/site-packages      
cp /usr/lib/python3.6/site-packages/pywraps2.py $VIRTUAL_ENV/lib/python3.6/site-packages
</code></pre>

<p>Here is a simple test map.</p>

<pre><code class="language-python">import folium
import pywraps2 as s2

# create a rect in s2
region_rect = s2.S2LatLngRect(
        s2.S2LatLng.FromDegrees(48.831776, 2.222639),
        s2.S2LatLng.FromDegrees(48.902839, 2.406))

# ask s2 to create a cover of this rect
coverer = s2.S2RegionCoverer()
coverer.set_min_level(10)
coverer.set_max_level(30)
coverer.set_max_cells(60)
covering = coverer.GetCovering(region_rect)
print([c.ToToken() for c in covering])

# create a map
map_osm = folium.Map(location=[48.86, 2.3],zoom_start=12, tiles='Stamen Toner')

# get vertices from rect to draw them on map
rect_vertices = []
for i in [0, 1, 2, 3, 0]:
    vertex = region_rect.GetVertex(i)
    rect_vertices.append([vertex.lat().degrees(), vertex.lng().degrees()])
    
# draw the cells
style_function = lambda x: {'weight': 1, 'fillColor':'#eea500'}
for cellid in covering:
    cell = s2.S2Cell(cellid)
    vertices = []
    for i in range(0, 4):
        vertex = cell.GetVertex(i)
        latlng = s2.S2LatLng(vertex)
        vertices.append([latlng.lng().degrees(),
                         latlng.lat().degrees()])
        
    gj = folium.GeoJson({ &quot;type&quot;: &quot;Polygon&quot;, &quot;coordinates&quot;: [vertices]}, style_function=style_function)
    gj.add_children(folium.Popup(cellid.ToToken()))
    gj.add_to(map_osm)
    
# warning PolyLine is lat,lng based while GeoJSON is not
ls = folium.PolyLine(rect_vertices, color='red', weight=2)
ls.add_children(folium.Popup(&quot;shape&quot;))
ls.add_to(map_osm)
    
map_osm
</code></pre>

<div style="width:100%;"><div style="position:relative;width:100%;height:0;padding-bottom:60%;"><iframe src="data:text/html;charset=utf-8;base64,PCFET0NUWVBFIGh0bWw+CjxoZWFkPiAgICAKICAgIDxtZXRhIGh0dHAtZXF1aXY9ImNvbnRlbnQtdHlwZSIgY29udGVudD0idGV4dC9odG1sOyBjaGFyc2V0PVVURi04IiAvPgogICAgPHNjcmlwdD5MX1BSRUZFUl9DQU5WQVMgPSBmYWxzZTsgTF9OT19UT1VDSCA9IGZhbHNlOyBMX0RJU0FCTEVfM0QgPSBmYWxzZTs8L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2FqYXguZ29vZ2xlYXBpcy5jb20vYWpheC9saWJzL2pxdWVyeS8xLjExLjEvanF1ZXJ5Lm1pbi5qcyI+PC9zY3JpcHQ+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvanMvYm9vdHN0cmFwLm1pbi5qcyI+PC9zY3JpcHQ+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvTGVhZmxldC5hd2Vzb21lLW1hcmtlcnMvMi4wLjIvbGVhZmxldC5hd2Vzb21lLW1hcmtlcnMuanMiPjwvc2NyaXB0PgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmNzcyIgLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvY3NzL2Jvb3RzdHJhcC5taW4uY3NzIiAvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MiIC8+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLzQuNi4zL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzcyIgLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvTGVhZmxldC5hd2Vzb21lLW1hcmtlcnMvMi4wLjIvbGVhZmxldC5hd2Vzb21lLW1hcmtlcnMuY3NzIiAvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL3Jhd2dpdC5jb20vcHl0aG9uLXZpc3VhbGl6YXRpb24vZm9saXVtL21hc3Rlci9mb2xpdW0vdGVtcGxhdGVzL2xlYWZsZXQuYXdlc29tZS5yb3RhdGUuY3NzIiAvPgogICAgPHN0eWxlPmh0bWwsIGJvZHkge3dpZHRoOiAxMDAlO2hlaWdodDogMTAwJTttYXJnaW46IDA7cGFkZGluZzogMDt9PC9zdHlsZT4KICAgIDxzdHlsZT4jbWFwIHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtib3R0b206MDtyaWdodDowO2xlZnQ6MDt9PC9zdHlsZT4KICAgIAogICAgICAgICAgICA8c3R5bGU+ICNtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYgewogICAgICAgICAgICAgICAgcG9zaXRpb24gOiByZWxhdGl2ZTsKICAgICAgICAgICAgICAgIHdpZHRoIDogMTAwLjAlOwogICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAuMCU7CiAgICAgICAgICAgICAgICBsZWZ0OiAwLjAlOwogICAgICAgICAgICAgICAgdG9wOiAwLjAlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICA8L3N0eWxlPgogICAgICAgIAo8L2hlYWQ+Cjxib2R5PiAgICAKICAgIAogICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb2xpdW0tbWFwIiBpZD0ibWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2IiA+PC9kaXY+CiAgICAgICAgCjwvYm9keT4KPHNjcmlwdD4gICAgCiAgICAKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IG51bGw7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNiA9IEwubWFwKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2VudGVyOiBbNDguODYsMi4zXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb206IDEyLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4Qm91bmRzOiBib3VuZHMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcnM6IFtdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRDb3B5SnVtcDogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcnM6IEwuQ1JTLkVQU0czODU3CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgdGlsZV9sYXllcl83NTg3NWRhYTdhMmY0YzQ0OGFlMzdlYWZmMTM2NzE5MSA9IEwudGlsZUxheWVyKAogICAgICAgICAgICAgICAgJ2h0dHBzOi8vc3RhbWVuLXRpbGVzLXtzfS5hLnNzbC5mYXN0bHkubmV0L3RvbmVyL3t6fS97eH0ve3l9LnBuZycsCiAgICAgICAgICAgICAgICB7CiAgImF0dHJpYnV0aW9uIjogbnVsbCwKICAiZGV0ZWN0UmV0aW5hIjogZmFsc2UsCiAgIm1heFpvb20iOiAxOCwKICAibWluWm9vbSI6IDEsCiAgIm5vV3JhcCI6IGZhbHNlLAogICJzdWJkb21haW5zIjogImFiYyIKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fNWNhNTZjMjRiYTUyNGRjYzgyZWVlZjM2ZTIyMTNhMTkgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMjM1NTI5NjQxNDE1NTQ0OCwgNDguODk4NjczOTY3MDIwOTJdLCBbMi4yMzYzMjI2ODUzNjI5NzA3LCA0OC45MDg3MzU1NzM2MzY5NF0sIFsyLjIyNTEwNjU4Mjk0MzY0NjUsIDQ4LjkwODk1MTk5Mzc0ODU4XSwgWzIuMjI0MzE3NTA4NDI4OTE0NiwgNDguODk4ODkwMjQ0MTU4MjI0XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl81Y2E1NmMyNGJhNTI0ZGNjODJlZWVmMzZlMjIxM2ExOS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9iMWJhYjI3Yjc2MTM0ZTZlYjk2OGMzNzk0OWU5YTc0MiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9lMDBmODBiZjM0YjA0Y2NhODg0YWEyYjllNjk5OWZjOCA9ICQoJzxkaXYgaWQ9Imh0bWxfZTAwZjgwYmYzNGIwNGNjYTg4NGFhMmI5ZTY5OTlmYzgiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY2NDU0PC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF9iMWJhYjI3Yjc2MTM0ZTZlYjk2OGMzNzk0OWU5YTc0Mi5zZXRDb250ZW50KGh0bWxfZTAwZjgwYmYzNGIwNGNjYTg4NGFhMmI5ZTY5OTlmYzgpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzVjYTU2YzI0YmE1MjRkY2M4MmVlZWYzNmUyMjEzYTE5LmJpbmRQb3B1cChwb3B1cF9iMWJhYjI3Yjc2MTM0ZTZlYjk2OGMzNzk0OWU5YTc0Mik7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzliMTFjNzhiMDNmZTRkODFhNDU0OGZjYzA5NDY5YzRkID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjIyNDMxNzUwODQyODkxNDYsIDQ4Ljg5ODg5MDI0NDE1ODIyNF0sIFsyLjIyNDcxMTk4ODQxODcyMTYsIDQ4LjkwMzkyMDg5NTgzMjA2XSwgWzIuMjE5MTA1ODQzODEwNjAyLCA0OC45MDQwMjg2NDQxNjk2NjRdLCBbMi4yMTg3MTIzNTU4OTYzODA0LCA0OC44OTg5OTc5NTY4OTg5Ml1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fOWIxMWM3OGIwM2ZlNGQ4MWE0NTQ4ZmNjMDk0NjljNGQuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfZjUwZjljYjVkOWM0NDJhNWI2ZWZmZjVmZjQ4Y2Q3OGQgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfNTE4YTNhYzhmZDM3NDQxNTk4MDU2ZmQwZmZlMGFkZTYgPSAkKCc8ZGl2IGlkPSJodG1sXzUxOGEzYWM4ZmQzNzQ0MTU5ODA1NmZkMGZmZTBhZGU2IiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NjQ1OTwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfZjUwZjljYjVkOWM0NDJhNWI2ZWZmZjVmZjQ4Y2Q3OGQuc2V0Q29udGVudChodG1sXzUxOGEzYWM4ZmQzNzQ0MTU5ODA1NmZkMGZmZTBhZGU2KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl85YjExYzc4YjAzZmU0ZDgxYTQ1NDhmY2MwOTQ2OWM0ZC5iaW5kUG9wdXAocG9wdXBfZjUwZjljYjVkOWM0NDJhNWI2ZWZmZjVmZjQ4Y2Q3OGQpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl9kOTE5OTI4MDg0YzU0MDI2OTk5MTlmZTczNjA4MDdkNSA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4yMjI1NDM3NjQ1NzY5NTcsIDQ4Ljg3NjI1NzgzNTIxODkzXSwgWzIuMjIyNzQwNzMyODczNTQ4LCA0OC44Nzg3NzIxMDA4ODkxOV0sIFsyLjIxOTk0MDA2MzE5NDk5OTMsIDQ4Ljg3ODgyNTkyMTU1NzYwNl0sIFsyLjIxOTc0MzM0MjU4MjcwNTYsIDQ4Ljg3NjMxMTY0Njk5NzA1XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9kOTE5OTI4MDg0YzU0MDI2OTk5MTlmZTczNjA4MDdkNS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF82YTIzYWY0ZDA5YTk0MGEyOGNiMWEwOTg3NjM2Yjk2YyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF82NmIyZjdlMjVlZDc0NWQwODlmZjEzMThmZWZhMzkyNyA9ICQoJzxkaXYgaWQ9Imh0bWxfNjZiMmY3ZTI1ZWQ3NDVkMDg5ZmYxMzE4ZmVmYTM5MjciIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY2NGMyYzwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNmEyM2FmNGQwOWE5NDBhMjhjYjFhMDk4NzYzNmI5NmMuc2V0Q29udGVudChodG1sXzY2YjJmN2UyNWVkNzQ1ZDA4OWZmMTMxOGZlZmEzOTI3KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl9kOTE5OTI4MDg0YzU0MDI2OTk5MTlmZTczNjA4MDdkNS5iaW5kUG9wdXAocG9wdXBfNmEyM2FmNGQwOWE5NDBhMjhjYjFhMDk4NzYzNmI5NmMpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl9kNjE3MTgxN2NkNDQ0NDYxYmMyMDBmNTExYzAyZWRlYiA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4yMzIzNjIwNjQyODI0NDcsIDQ4Ljg1ODQ0NTM5NTI1NTkxXSwgWzIuMjMzMTUzMjY5NTI3NzE5NCwgNDguODY4NDk5ODU5MTk0NzNdLCBbMi4yMjE5NTMwMzEwNzU3ODU2LCA0OC44Njg3MTU3MDgwMDg3MTVdLCBbMi4yMjExNjU3ODYwOTM5MDI1LCA0OC44NTg2NjExMDE0OTUxM11dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fZDYxNzE4MTdjZDQ0NDQ2MWJjMjAwZjUxMWMwMmVkZWIuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfYzI3YjE2ZmNhODdkNGYwYmJjYzUzZTVkMzE2ZjE5OWYgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfNjk1MjJmYjI4NmYxNGQyODhiYWVkMDQ4ODMzYzkzNTEgPSAkKCc8ZGl2IGlkPSJodG1sXzY5NTIyZmIyODZmMTRkMjg4YmFlZDA0ODgzM2M5MzUxIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NjRkNDwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfYzI3YjE2ZmNhODdkNGYwYmJjYzUzZTVkMzE2ZjE5OWYuc2V0Q29udGVudChodG1sXzY5NTIyZmIyODZmMTRkMjg4YmFlZDA0ODgzM2M5MzUxKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl9kNjE3MTgxN2NkNDQ0NDYxYmMyMDBmNTExYzAyZWRlYi5iaW5kUG9wdXAocG9wdXBfYzI3YjE2ZmNhODdkNGYwYmJjYzUzZTVkMzE2ZjE5OWYpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl8wMDlmYmNiYTA4NzA0MmE3ODEzMmQ1NDEzNDhjMzJiYSA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4yMzMxNTMyNjk1Mjc3MTk0LCA0OC44Njg0OTk4NTkxOTQ3M10sIFsyLjIzMzk0NDkzMzg3ODM3LCA0OC44Nzg1NTYxMDk0MDA2NV0sIFsyLjIyMjc0MDczMjg3MzU0OCwgNDguODc4NzcyMTAwODg5MTldLCBbMi4yMjE5NTMwMzEwNzU3ODU2LCA0OC44Njg3MTU3MDgwMDg3MTVdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzAwOWZiY2JhMDg3MDQyYTc4MTMyZDU0MTM0OGMzMmJhLnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzBmZGZiMDQxNzA0ODRjOGQ5YmJjNzVmNTUyZWQ0NzU1ID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2ZlOGQ2OWRiZTYzMjQ1Yjk4MjM5MDkwZDExMTViYWI3ID0gJCgnPGRpdiBpZD0iaHRtbF9mZThkNjlkYmU2MzI0NWI5ODIzOTA5MGQxMTE1YmFiNyIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjY0ZGM8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzBmZGZiMDQxNzA0ODRjOGQ5YmJjNzVmNTUyZWQ0NzU1LnNldENvbnRlbnQoaHRtbF9mZThkNjlkYmU2MzI0NWI5ODIzOTA5MGQxMTE1YmFiNyk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fMDA5ZmJjYmEwODcwNDJhNzgxMzJkNTQxMzQ4YzMyYmEuYmluZFBvcHVwKHBvcHVwXzBmZGZiMDQxNzA0ODRjOGQ5YmJjNzVmNTUyZWQ0NzU1KTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fYmU2NjRlMzZjYzJjNGVkNDg3ODcxN2U5ZDkxYTNhODYgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMjMzOTQ0OTMzODc4MzcsIDQ4Ljg3ODU1NjEwOTQwMDY1XSwgWzIuMjM1NTI5NjQxNDE1NTQ0OCwgNDguODk4NjczOTY3MDIwOTJdLCBbMi4yMTMxMDc4MTI4MzMyNTMsIDQ4Ljg5OTEwNTM4NTg3MjgzNl0sIFsyLjIxMTUzODk2Nzc3NjU2MjQsIDQ4Ljg3ODk4Njk1ODQ1MTQ4NV1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fYmU2NjRlMzZjYzJjNGVkNDg3ODcxN2U5ZDkxYTNhODYuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfYjFkM2IxMDQ5ZjA4NDNlNGJhODgwMTAyNTkzOWU4NGUgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMTc4ZmUxMmZiOGM1NGRkYjg2M2M3YmYxOWU1NTU0NzcgPSAkKCc8ZGl2IGlkPSJodG1sXzE3OGZlMTJmYjhjNTRkZGI4NjNjN2JmMTllNTU1NDc3IiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NjRmPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF9iMWQzYjEwNDlmMDg0M2U0YmE4ODAxMDI1OTM5ZTg0ZS5zZXRDb250ZW50KGh0bWxfMTc4ZmUxMmZiOGM1NGRkYjg2M2M3YmYxOWU1NTU0NzcpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uX2JlNjY0ZTM2Y2MyYzRlZDQ4Nzg3MTdlOWQ5MWEzYTg2LmJpbmRQb3B1cChwb3B1cF9iMWQzYjEwNDlmMDg0M2U0YmE4ODAxMDI1OTM5ZTg0ZSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uX2E2Y2QzNTFmYjg4MzQ1ZjQ4MjNiZTgyZmYxNzk5MWVhID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjI3NzE3MTUwMTg4MDE3OSwgNDguODU3NTcxMjMxNzk1NzQ1XSwgWzIuMjgwNDAyNTI3NzczODkxNywgNDguODk3Nzk3NDkwMDI1MDg0XSwgWzIuMjM1NTI5NjQxNDE1NTQ0OCwgNDguODk4NjczOTY3MDIwOTJdLCBbMi4yMzIzNjIwNjQyODI0NDcsIDQ4Ljg1ODQ0NTM5NTI1NTkxXV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9hNmNkMzUxZmI4ODM0NWY0ODIzYmU4MmZmMTc5OTFlYS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9lZDIxMGI1MGVkYjc0NjMyYjlmZDI3NWI5MjJiMzFiMyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF8zOGQyY2FlMjdhYjA0NzAyYmI0N2RkNDg1ZWIwZGYzZiA9ICQoJzxkaXYgaWQ9Imh0bWxfMzhkMmNhZTI3YWIwNDcwMmJiNDdkZDQ4NWViMGRmM2YiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY2NTQ8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2VkMjEwYjUwZWRiNzQ2MzJiOWZkMjc1YjkyMmIzMWIzLnNldENvbnRlbnQoaHRtbF8zOGQyY2FlMjdhYjA0NzAyYmI0N2RkNDg1ZWIwZGYzZik7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fYTZjZDM1MWZiODgzNDVmNDgyM2JlODJmZjE3OTkxZWEuYmluZFBvcHVwKHBvcHVwX2VkMjEwYjUwZWRiNzQ2MzJiOWZkMjc1YjkyMmIzMWIzKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fMWVhYWE2OGE2ZmY1NDQzZTk0YjhkMzRhZTE2YjU3YTkgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMjgwNDAyNTI3NzczODkxNywgNDguODk3Nzk3NDkwMDI1MDg0XSwgWzIuMjgxMjExNDU2ODUxNjA2LCA0OC45MDc4NTg1MTcyNDQ3OF0sIFsyLjI2OTk4NTYxMTY2MjQ1OCwgNDguOTA4MDc5NDg5MTU3MjNdLCBbMi4yNjkxODA2NTQ5NzUxNzM2LCA0OC44OTgwMTgzMTU5NjI3Ml1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fMWVhYWE2OGE2ZmY1NDQzZTk0YjhkMzRhZTE2YjU3YTkuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfYzI4YTAyOWI2NWYzNGUwNDhhNDA4YjRjYTU1ZDE3YjMgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfY2JiNmFhZjJmNGRhNDcxMWJiNTQ1ZDQ1MmY5OTE4ZTQgPSAkKCc8ZGl2IGlkPSJodG1sX2NiYjZhYWYyZjRkYTQ3MTFiYjU0NWQ0NTJmOTkxOGU0IiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NjU4NDwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfYzI4YTAyOWI2NWYzNGUwNDhhNDA4YjRjYTU1ZDE3YjMuc2V0Q29udGVudChodG1sX2NiYjZhYWYyZjRkYTQ3MTFiYjU0NWQ0NTJmOTkxOGU0KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl8xZWFhYTY4YTZmZjU0NDNlOTRiOGQzNGFlMTZiNTdhOS5iaW5kUG9wdXAocG9wdXBfYzI4YTAyOWI2NWYzNGUwNDhhNDA4YjRjYTU1ZDE3YjMpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl9hOTI3ODA2NzI4NDA0ODIyODI0NmNkM2VkODJjMDQ4NSA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4yNjkxODA2NTQ5NzUxNzM2LCA0OC44OTgwMTgzMTU5NjI3Ml0sIFsyLjI2OTk4NTYxMTY2MjQ1OCwgNDguOTA4MDc5NDg5MTU3MjNdLCBbMi4yNTg3NjIyMDA2OTkxNiwgNDguOTA4Mjk5MzIyMDUyNl0sIFsyLjI1Nzk2MTIxNTY2NDQyNCwgNDguODk4MjM4MDAzNjM0MDhdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uX2E5Mjc4MDY3Mjg0MDQ4MjI4MjQ2Y2QzZWQ4MmMwNDg1LnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzNkNmNkYzhjMDMwNzQ4YTA4NGVjNjk0ZTBhMGJmMmNjID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzBmMTU2YzAxYTNlNzQxYTI4ZGFhODZiYmNhZmVlYTVjID0gJCgnPGRpdiBpZD0iaHRtbF8wZjE1NmMwMWEzZTc0MWEyOGRhYTg2YmJjYWZlZWE1YyIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjY1OWM8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzNkNmNkYzhjMDMwNzQ4YTA4NGVjNjk0ZTBhMGJmMmNjLnNldENvbnRlbnQoaHRtbF8wZjE1NmMwMWEzZTc0MWEyOGRhYTg2YmJjYWZlZWE1Yyk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fYTkyNzgwNjcyODQwNDgyMjgyNDZjZDNlZDgyYzA0ODUuYmluZFBvcHVwKHBvcHVwXzNkNmNkYzhjMDMwNzQ4YTA4NGVjNjk0ZTBhMGJmMmNjKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fMmYwZTdlZWQzNTI2NDQ4YmI5Y2FhNWU5ODc2ZWIxM2QgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMjU3OTYxMjE1NjY0NDI0LCA0OC44OTgyMzgwMDM2MzQwOF0sIFsyLjI1ODc2MjIwMDY5OTE2LCA0OC45MDgyOTkzMjIwNTI2XSwgWzIuMjQ3NTQxMjI0OTQwMjEyMiwgNDguOTA4NTE4MDE2NjQyMDhdLCBbMi4yNDY3NDQyMTA4MTkxMDc2LCA0OC44OTg0NTY1NTM3NDk4Nl1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fMmYwZTdlZWQzNTI2NDQ4YmI5Y2FhNWU5ODc2ZWIxM2Quc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfOWIzYjUzOTdjMmRiNGMwMzhiYTE0YjRlZmFiMzRhNmQgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfZDJlOWFkYjg3MGE4NGE1MDgwYmI5MTJhNGQyOTAzY2UgPSAkKCc8ZGl2IGlkPSJodG1sX2QyZTlhZGI4NzBhODRhNTA4MGJiOTEyYTRkMjkwM2NlIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NjVhNDwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfOWIzYjUzOTdjMmRiNGMwMzhiYTE0YjRlZmFiMzRhNmQuc2V0Q29udGVudChodG1sX2QyZTlhZGI4NzBhODRhNTA4MGJiOTEyYTRkMjkwM2NlKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl8yZjBlN2VlZDM1MjY0NDhiYjljYWE1ZTk4NzZlYjEzZC5iaW5kUG9wdXAocG9wdXBfOWIzYjUzOTdjMmRiNGMwMzhiYTE0YjRlZmFiMzRhNmQpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl8zODRjNzBmZTIxMDk0ZTZkOTJiMGU4YTc4ZjFiM2Q4OCA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4yNDY3NDQyMTA4MTkxMDc2LCA0OC44OTg0NTY1NTM3NDk4Nl0sIFsyLjI0NzU0MTIyNDk0MDIxMjIsIDQ4LjkwODUxODAxNjY0MjA4XSwgWzIuMjM2MzIyNjg1MzYyOTcwNywgNDguOTA4NzM1NTczNjM2OTRdLCBbMi4yMzU1Mjk2NDE0MTU1NDQ4LCA0OC44OTg2NzM5NjcwMjA5Ml1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fMzg0YzcwZmUyMTA5NGU2ZDkyYjBlOGE3OGYxYjNkODguc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfNjY3NjhlODljYWMwNGYyODk2MjcxZmEzY2RlMDQ5MTAgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfZDM2MzIxNWU5ZjU5NGNhNDgwOGI5M2NmMmNkMjM0OWQgPSAkKCc8ZGl2IGlkPSJodG1sX2QzNjMyMTVlOWY1OTRjYTQ4MDhiOTNjZjJjZDIzNDlkIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NjVhYzwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNjY3NjhlODljYWMwNGYyODk2MjcxZmEzY2RlMDQ5MTAuc2V0Q29udGVudChodG1sX2QzNjMyMTVlOWY1OTRjYTQ4MDhiOTNjZjJjZDIzNDlkKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl8zODRjNzBmZTIxMDk0ZTZkOTJiMGU4YTc4ZjFiM2Q4OC5iaW5kUG9wdXAocG9wdXBfNjY3NjhlODljYWMwNGYyODk2MjcxZmEzY2RlMDQ5MTApOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl9kYmRmNjg2YWJjNTg0MWVlYjlkMGRlYmQ2OTMxODFjMyA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4zODE1MDg3MjgwNzM3NDM3LCA0OC44OTU3NTg3MTczOTQ4N10sIFsyLjM4MjM1MzQ0MTY5ODU0NywgNDguOTA1ODE4Mzk2OTgzMTldLCBbMi4zNzExMDU3MzI2OTc5ODA1LCA0OC45MDYwNDk2NTIwMzE0MV0sIFsyLjM3MDI2NDk5ODA1Nzc0NzMsIDQ4Ljg5NTk4OTgxOTY5MTM1XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9kYmRmNjg2YWJjNTg0MWVlYjlkMGRlYmQ2OTMxODFjMy5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF84MGY2MGZmYjkzZjE0MjY0OTBlMjY0YzI1YzU4YWJkNSA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9hMWY3ZGJiNmY2ZWE0Yjg5YmI1MDJiZWFiNDA0MGJlZSA9ICQoJzxkaXYgaWQ9Imh0bWxfYTFmN2RiYjZmNmVhNGI4OWJiNTAyYmVhYjQwNDBiZWUiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY2YzJjPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF84MGY2MGZmYjkzZjE0MjY0OTBlMjY0YzI1YzU4YWJkNS5zZXRDb250ZW50KGh0bWxfYTFmN2RiYjZmNmVhNGI4OWJiNTAyYmVhYjQwNDBiZWUpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uX2RiZGY2ODZhYmM1ODQxZWViOWQwZGViZDY5MzE4MWMzLmJpbmRQb3B1cChwb3B1cF84MGY2MGZmYjkzZjE0MjY0OTBlMjY0YzI1YzU4YWJkNSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uX2UwZTA2MmZiZDk3NzRkZmY4YWM3ZjBmMjcyNjdmYTgyID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjM5Mjc1NDg4MTc0MDIwOCwgNDguODk1NTI2NDY5NzMxNjg1XSwgWzIuMzkzNjAzNTc1MDc3MDQxMiwgNDguOTA1NTg1OTk1ODEzMDM0XSwgWzIuMzgyMzUzNDQxNjk4NTQ3LCA0OC45MDU4MTgzOTY5ODMxOV0sIFsyLjM4MTUwODcyODA3Mzc0MzcsIDQ4Ljg5NTc1ODcxNzM5NDg3XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9lMGUwNjJmYmQ5Nzc0ZGZmOGFjN2YwZjI3MjY3ZmE4Mi5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF82ZjZjMDhiOWEyYTg0ODY3OGQ1Mjg3N2VhNmRhMGViYyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9hYWEzNmVkYmM1NmE0MGJlOGY2MWVhMTU2ZTA0NGEzNiA9ICQoJzxkaXYgaWQ9Imh0bWxfYWFhMzZlZGJjNTZhNDBiZThmNjFlYTE1NmUwNDRhMzYiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY2YzM0PC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF82ZjZjMDhiOWEyYTg0ODY3OGQ1Mjg3N2VhNmRhMGViYy5zZXRDb250ZW50KGh0bWxfYWFhMzZlZGJjNTZhNDBiZThmNjFlYTE1NmUwNDRhMzYpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uX2UwZTA2MmZiZDk3NzRkZmY4YWM3ZjBmMjcyNjdmYTgyLmJpbmRQb3B1cChwb3B1cF82ZjZjMDhiOWEyYTg0ODY3OGQ1Mjg3N2VhNmRhMGViYyk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uX2FjNTY5N2VjNGU0OTQ0NzJhM2JjYjc5Mjc1ZTBmYTFmID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjQwNDAwMzQ1ODA2NzEwMDYsIDQ4Ljg5NTI5MzA3NTk5MjQwNl0sIFsyLjQwNDg1NjEzMTg0MjM3NzYsIDQ4LjkwNTM1MjQ0NzgxMTE2XSwgWzIuMzkzNjAzNTc1MDc3MDQxMiwgNDguOTA1NTg1OTk1ODEzMDM0XSwgWzIuMzkyNzU0ODgxNzQwMjA4LCA0OC44OTU1MjY0Njk3MzE2ODVdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uX2FjNTY5N2VjNGU0OTQ0NzJhM2JjYjc5Mjc1ZTBmYTFmLnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2M0MmM1NzdmNjc5ZTRkZmFiNGUyZWQxMTA2NGFkZDYwID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzY0MDgxNDg0ZGIwZDQyMWZiYzliYmI4YWJlODBmMjJhID0gJCgnPGRpdiBpZD0iaHRtbF82NDA4MTQ4NGRiMGQ0MjFmYmM5YmJiOGFiZTgwZjIyYSIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjZjNGM8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2M0MmM1NzdmNjc5ZTRkZmFiNGUyZWQxMTA2NGFkZDYwLnNldENvbnRlbnQoaHRtbF82NDA4MTQ4NGRiMGQ0MjFmYmM5YmJiOGFiZTgwZjIyYSk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fYWM1Njk3ZWM0ZTQ5NDQ3MmEzYmNiNzkyNzVlMGZhMWYuYmluZFBvcHVwKHBvcHVwX2M0MmM1NzdmNjc5ZTRkZmFiNGUyZWQxMTA2NGFkZDYwKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fOGI5ODYxNjZlNDFkNDY2OWJhZTk2OTAxY2QyZjNlNjUgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuNDEwMDU1OTI0NTQzODQ5OCwgNDguOTAwMjA1MzczNDE3OTNdLCBbMi40MTA0ODMzMTg2ODUwODM0LCA0OC45MDUyMzUyNDM1MjY1NF0sIFsyLjQwNDg1NjEzMTg0MjM3NzYsIDQ4LjkwNTM1MjQ0NzgxMTE2XSwgWzIuNDA0NDI5NzMzMDkwNTg0NiwgNDguOTAwMzIyNTM4OTg4MzhdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzhiOTg2MTY2ZTQxZDQ2NjliYWU5NjkwMWNkMmYzZTY1LnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzQxN2VhODYzMzgzNDQwZmM4YzM0ODc3NDYzODIzZDhiID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzk4MTQ1YjlkMjdlZDRhMTQ4ZGM3YmYwYjMzZGExMjM4ID0gJCgnPGRpdiBpZD0iaHRtbF85ODE0NWI5ZDI3ZWQ0YTE0OGRjN2JmMGIzM2RhMTIzOCIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjZjNTE8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzQxN2VhODYzMzgzNDQwZmM4YzM0ODc3NDYzODIzZDhiLnNldENvbnRlbnQoaHRtbF85ODE0NWI5ZDI3ZWQ0YTE0OGRjN2JmMGIzM2RhMTIzOCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fOGI5ODYxNjZlNDFkNDY2OWJhZTk2OTAxY2QyZjNlNjUuYmluZFBvcHVwKHBvcHVwXzQxN2VhODYzMzgzNDQwZmM4YzM0ODc3NDYzODIzZDhiKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fYjAyNWFhOGU0NWZlNDM4ZDgxYTcxN2NjYjZiOTY5NzIgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuNDA5NjI4NjU0NDE4NTA3LCA0OC44OTUxNzU5NDkxMjI1OTZdLCBbMi40MTAwNTU5MjQ1NDM4NDk4LCA0OC45MDAyMDUzNzM0MTc5M10sIFsyLjQwNDQyOTczMzA5MDU4NDYsIDQ4LjkwMDMyMjUzODk4ODM4XSwgWzIuNDA0MDAzNDU4MDY3MTAwNiwgNDguODk1MjkzMDc1OTkyNDA2XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9iMDI1YWE4ZTQ1ZmU0MzhkODFhNzE3Y2NiNmI5Njk3Mi5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF8yYmM1YjE1MzI1Mjk0N2U3ODM5NzNhMTZlOTc5NWFhMSA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF81YzQyMzJhNzc5Y2M0YzZjOTBjZjAxYWEwOGUzNWJjNyA9ICQoJzxkaXYgaWQ9Imh0bWxfNWM0MjMyYTc3OWNjNGM2YzkwY2YwMWFhMDhlMzViYzciIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY2YzUzPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF8yYmM1YjE1MzI1Mjk0N2U3ODM5NzNhMTZlOTc5NWFhMS5zZXRDb250ZW50KGh0bWxfNWM0MjMyYTc3OWNjNGM2YzkwY2YwMWFhMDhlMzViYzcpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uX2IwMjVhYThlNDVmZTQzOGQ4MWE3MTdjY2I2Yjk2OTcyLmJpbmRQb3B1cChwb3B1cF8yYmM1YjE1MzI1Mjk0N2U3ODM5NzNhMTZlOTc5NWFhMSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uX2QxMTBmY2I4NjUwYTRjYTFhNGYzZGY4YTY0MjQ0YmYzID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjQxMTgzMjgwMjI4NDM1NTQsIDQ4Ljg1NDgzOTUwNjI2NTY4XSwgWzIuNDE1MjU0NDU2MDYzMjM4MywgNDguODk1MDU4NTM1NDY3ODJdLCBbMi4zNzAyNjQ5OTgwNTc3NDczLCA0OC44OTU5ODk4MTk2OTEzNV0sIFsyLjM2NjkwNjkzMzU3NTIzNCwgNDguODU1NzY4MzMyNjMwMjhdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uX2QxMTBmY2I4NjUwYTRjYTFhNGYzZGY4YTY0MjQ0YmYzLnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2E2ZTZjOTU1MDI0OTQyOWJiMjg2MDk5NWQwMWMxM2MwID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2U3NzFiNzVmMzM2YTRkZGNhNWNjNjc4ZjAyODI2ZjQzID0gJCgnPGRpdiBpZD0iaHRtbF9lNzcxYjc1ZjMzNmE0ZGRjYTVjYzY3OGYwMjgyNmY0MyIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjZkYzwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfYTZlNmM5NTUwMjQ5NDI5YmIyODYwOTk1ZDAxYzEzYzAuc2V0Q29udGVudChodG1sX2U3NzFiNzVmMzM2YTRkZGNhNWNjNjc4ZjAyODI2ZjQzKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl9kMTEwZmNiODY1MGE0Y2ExYTRmM2RmOGE2NDI0NGJmMy5iaW5kUG9wdXAocG9wdXBfYTZlNmM5NTUwMjQ5NDI5YmIyODYwOTk1ZDAxYzEzYzApOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl81ODBhNmY2YzczMjM0MmRhOWY3Yjc3ODMzYjFmZDBhNyA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4zNjY5MDY5MzM1NzUyMzQsIDQ4Ljg1NTc2ODMzMjYzMDI4XSwgWzIuMzcwMjY0OTk4MDU3NzQ3MywgNDguODk1OTg5ODE5NjkxMzVdLCBbMi4zMjUzMTQzMzQyNTkxODUsIDQ4Ljg5NjkwMjc4OTQwMTQ2Nl0sIFsyLjMyMjAxOTgxMjQ5Mzg5MywgNDguODU2Njc4ODkyNzAyMzVdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzU4MGE2ZjZjNzMyMzQyZGE5ZjdiNzc4MzNiMWZkMGE3LnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzQyODg0YWNkNGE5OTQxMzY4NWQ4OTY3MGEwMWI1NjIwID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2RjZDNjZmVlMjVkMTRhNDZhYzRjMDljYTZjYjcxZjA1ID0gJCgnPGRpdiBpZD0iaHRtbF9kY2QzY2ZlZTI1ZDE0YTQ2YWM0YzA5Y2E2Y2I3MWYwNSIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjZlNDwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNDI4ODRhY2Q0YTk5NDEzNjg1ZDg5NjcwYTAxYjU2MjAuc2V0Q29udGVudChodG1sX2RjZDNjZmVlMjVkMTRhNDZhYzRjMDljYTZjYjcxZjA1KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl81ODBhNmY2YzczMjM0MmRhOWY3Yjc3ODMzYjFmZDBhNy5iaW5kUG9wdXAocG9wdXBfNDI4ODRhY2Q0YTk5NDEzNjg1ZDg5NjcwYTAxYjU2MjApOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl84NDY5NTgyNmNlYzE0OTI3YTVkMTY1OGZkMjg4Nzg2ZSA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4zNzAyNjQ5OTgwNTc3NDczLCA0OC44OTU5ODk4MTk2OTEzNV0sIFsyLjM3MTEwNTczMjY5Nzk4MDUsIDQ4LjkwNjA0OTY1MjAzMTQxXSwgWzIuMzU5ODYwNDQ5MDY1Mjg1NywgNDguOTA2Mjc5NzYxNjY3NjFdLCBbMi4zNTkwMjM2OTI2ODExMTMsIDQ4Ljg5NjIxOTc3NzMzMDU3XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl84NDY5NTgyNmNlYzE0OTI3YTVkMTY1OGZkMjg4Nzg2ZS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF8xODg1OTE4NWQwMjQ0N2QyOWE4MTUyOThkMTc5Zjc4MCA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9lMjVhY2VlZTQ1ODE0NDg5YTQ0NDU4ZDkzMmM2NzZhNyA9ICQoJzxkaXYgaWQ9Imh0bWxfZTI1YWNlZWU0NTgxNDQ4OWE0NDQ1OGQ5MzJjNjc2YTciIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY2ZTg0PC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF8xODg1OTE4NWQwMjQ0N2QyOWE4MTUyOThkMTc5Zjc4MC5zZXRDb250ZW50KGh0bWxfZTI1YWNlZWU0NTgxNDQ4OWE0NDQ1OGQ5MzJjNjc2YTcpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzg0Njk1ODI2Y2VjMTQ5MjdhNWQxNjU4ZmQyODg3ODZlLmJpbmRQb3B1cChwb3B1cF8xODg1OTE4NWQwMjQ0N2QyOWE4MTUyOThkMTc5Zjc4MCk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uX2NjMTZiNGM5YWVjMjRlZWQ5OWI1NjQ5OGYxMTljNzU2ID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjM1OTAyMzY5MjY4MTExMywgNDguODk2MjE5Nzc3MzMwNTddLCBbMi4zNTk4NjA0NDkwNjUyODU3LCA0OC45MDYyNzk3NjE2Njc2MV0sIFsyLjM0ODYxNzU5MTc4OTI1OTgsIDQ4LjkwNjUwODcyNjYwMTg2XSwgWzIuMzQ3Nzg0ODEyOTMxNTkzNSwgNDguODk2NDQ4NTkxMDIyMTVdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uX2NjMTZiNGM5YWVjMjRlZWQ5OWI1NjQ5OGYxMTljNzU2LnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2U4NTBmMjFhYWYxZjQwOGNiYzFlY2EwNjViM2U2MzIwID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2FiMWQ4NjhhYjJmNjQ4YWFiZTE0ZDUwN2RmYTlhOWFhID0gJCgnPGRpdiBpZD0iaHRtbF9hYjFkODY4YWIyZjY0OGFhYmUxNGQ1MDdkZmE5YTlhYSIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjZlOGM8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2U4NTBmMjFhYWYxZjQwOGNiYzFlY2EwNjViM2U2MzIwLnNldENvbnRlbnQoaHRtbF9hYjFkODY4YWIyZjY0OGFhYmUxNGQ1MDdkZmE5YTlhYSk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fY2MxNmI0YzlhZWMyNGVlZDk5YjU2NDk4ZjExOWM3NTYuYmluZFBvcHVwKHBvcHVwX2U4NTBmMjFhYWYxZjQwOGNiYzFlY2EwNjViM2U2MzIwKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fMzhiNzZiMmQxZmI2NDQwZGE3NjBiMWM2ZTNmYWFiMDggPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMzQ3Nzg0ODEyOTMxNTkzNSwgNDguODk2NDQ4NTkxMDIyMTVdLCBbMi4zNDg2MTc1OTE3ODkyNTk4LCA0OC45MDY1MDg3MjY2MDE4Nl0sIFsyLjMzNzM3NzE2MTg1NzU1NjMsIDQ4LjkwNjczNjU0NzU0NDMyXSwgWzIuMzM2NTQ4MzU5Nzk1Nzk1NCwgNDguODk2Njc2MjYxNDc1ODI1XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl8zOGI3NmIyZDFmYjY0NDBkYTc2MGIxYzZlM2ZhYWIwOC5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF8xMWZkZDczZjlmZjM0OTNiOWM2ZjRkMjQxZDlmZjgxYiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF8wOWRlZjVhYWMzOTE0YWFmODg1Yjk2NDE1ZWFiMDA4MyA9ICQoJzxkaXYgaWQ9Imh0bWxfMDlkZWY1YWFjMzkxNGFhZjg4NWI5NjQxNWVhYjAwODMiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY2ZWY0PC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF8xMWZkZDczZjlmZjM0OTNiOWM2ZjRkMjQxZDlmZjgxYi5zZXRDb250ZW50KGh0bWxfMDlkZWY1YWFjMzkxNGFhZjg4NWI5NjQxNWVhYjAwODMpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzM4Yjc2YjJkMWZiNjQ0MGRhNzYwYjFjNmUzZmFhYjA4LmJpbmRQb3B1cChwb3B1cF8xMWZkZDczZjlmZjM0OTNiOWM2ZjRkMjQxZDlmZjgxYik7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzI0YzM0ZWM2ZjY3NDQwYzFhNzE1ZTU1NTg4YjkyOWI5ID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjMzNjU0ODM1OTc5NTc5NTQsIDQ4Ljg5NjY3NjI2MTQ3NTgyNV0sIFsyLjMzNzM3NzE2MTg1NzU1NjMsIDQ4LjkwNjczNjU0NzU0NDMyXSwgWzIuMzI2MTM5MTYwMjU2NjgyNSwgNDguOTA2OTYzMjI1MjA1M10sIFsyLjMyNTMxNDMzNDI1OTE4NSwgNDguODk2OTAyNzg5NDAxNDY2XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl8yNGMzNGVjNmY2NzQ0MGMxYTcxNWU1NTU4OGI5MjliOS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9hOWEwNmZlNjkxNTQ0YjRiOTZlNjYwMmNlYjYwNzM4YyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9iMGExZTVmM2Q3ZDg0Y2Q3YTg4NmNmNTNkMjI0YWM2OSA9ICQoJzxkaXYgaWQ9Imh0bWxfYjBhMWU1ZjNkN2Q4NGNkN2E4ODZjZjUzZDIyNGFjNjkiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY2ZWZjPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF9hOWEwNmZlNjkxNTQ0YjRiOTZlNjYwMmNlYjYwNzM4Yy5zZXRDb250ZW50KGh0bWxfYjBhMWU1ZjNkN2Q4NGNkN2E4ODZjZjUzZDIyNGFjNjkpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzI0YzM0ZWM2ZjY3NDQwYzFhNzE1ZTU1NTg4YjkyOWI5LmJpbmRQb3B1cChwb3B1cF9hOWEwNmZlNjkxNTQ0YjRiOTZlNjYwMmNlYjYwNzM4Yyk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzk3YmRjY2ExZjAyNDQxMWViNGMyNDYxY2I0YTA4NzY0ID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjMyNTMxNDMzNDI1OTE4NSwgNDguODk2OTAyNzg5NDAxNDY2XSwgWzIuMzI2MTM5MTYwMjU2NjgyNSwgNDguOTA2OTYzMjI1MjA1M10sIFsyLjMxNDkwMzU4Nzk3MjAwMzIsIDQ4LjkwNzE4ODc2MDI5NTIyXSwgWzIuMzE0MDgyNzM3MzA2MDgyNCwgNDguODk3MTI4MTc1NTA5MDRdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzk3YmRjY2ExZjAyNDQxMWViNGMyNDYxY2I0YTA4NzY0LnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzFlZjM5MTVmNGY1MzRlMzM5MmM2OWExNzRmYzY5MmRkID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzNhODk5MDI5ZjgzNjQ3MjlhZmQ1OWFlNGIxMzYwYTYzID0gJCgnPGRpdiBpZD0iaHRtbF8zYTg5OTAyOWY4MzY0NzI5YWZkNTlhZTRiMTM2MGE2MyIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjZmMDQ8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzFlZjM5MTVmNGY1MzRlMzM5MmM2OWExNzRmYzY5MmRkLnNldENvbnRlbnQoaHRtbF8zYTg5OTAyOWY4MzY0NzI5YWZkNTlhZTRiMTM2MGE2Myk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fOTdiZGNjYTFmMDI0NDExZWI0YzI0NjFjYjRhMDg3NjQuYmluZFBvcHVwKHBvcHVwXzFlZjM5MTVmNGY1MzRlMzM5MmM2OWExNzRmYzY5MmRkKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fY2MxODYyNmY2MGQzNDA2MzlkZjAzNzhhZmM4MTBjODggPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMzE0MDgyNzM3MzA2MDgyNCwgNDguODk3MTI4MTc1NTA5MDRdLCBbMi4zMTQ5MDM1ODc5NzIwMDMyLCA0OC45MDcxODg3NjAyOTUyMl0sIFsyLjMwMzY3MDQ0NTk4NzczNzcsIDQ4LjkwNzQxMzE1MzUyNDY0XSwgWzIuMzAyODUzNTY5OTE5NjY3MywgNDguODk3MzUyNDIwNTA4NjVdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uX2NjMTg2MjZmNjBkMzQwNjM5ZGYwMzc4YWZjODEwYzg4LnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzU5ZDAzNjU4NWVhMzRmOTk4MDY4ODE4OTNjZTkzYTEyID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2IwNDE3ZTY3MzE0ODQ5ZjBhMmRkMjA4ZWRhMWRlM2NhID0gJCgnPGRpdiBpZD0iaHRtbF9iMDQxN2U2NzMxNDg0OWYwYTJkZDIwOGVkYTFkZTNjYSIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjZmMGM8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzU5ZDAzNjU4NWVhMzRmOTk4MDY4ODE4OTNjZTkzYTEyLnNldENvbnRlbnQoaHRtbF9iMDQxN2U2NzMxNDg0OWYwYTJkZDIwOGVkYTFkZTNjYSk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fY2MxODYyNmY2MGQzNDA2MzlkZjAzNzhhZmM4MTBjODguYmluZFBvcHVwKHBvcHVwXzU5ZDAzNjU4NWVhMzRmOTk4MDY4ODE4OTNjZTkzYTEyKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fZTVkYjcxNWI3YWI1NDgxMWI2NTQxNGE2Mjg1NjJiYzUgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMzAyODUzNTY5OTE5NjY3MywgNDguODk3MzUyNDIwNTA4NjVdLCBbMi4zMDM2NzA0NDU5ODc3Mzc3LCA0OC45MDc0MTMxNTM1MjQ2NF0sIFsyLjI5MjQzOTczNTI4Njk2MTQsIDQ4LjkwNzYzNjQwNTYwNDIzXSwgWzIuMjkxNjI2ODMzMDgxOTcyNywgNDguODk3NTc1NTI1MTEwNTU0XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9lNWRiNzE1YjdhYjU0ODExYjY1NDE0YTYyODU2MmJjNS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF8wYjBkMjgxYjFkNzY0MDA0YmY3NTk3OTZhNzYxZjhiNCA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF8yZDdlNDk0MjRmMzE0NGQ4OGMzZDk4NzZiZjU5NTYwZSA9ICQoJzxkaXYgaWQ9Imh0bWxfMmQ3ZTQ5NDI0ZjMxNDRkODhjM2Q5ODc2YmY1OTU2MGUiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY2Zjc0PC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF8wYjBkMjgxYjFkNzY0MDA0YmY3NTk3OTZhNzYxZjhiNC5zZXRDb250ZW50KGh0bWxfMmQ3ZTQ5NDI0ZjMxNDRkODhjM2Q5ODc2YmY1OTU2MGUpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uX2U1ZGI3MTViN2FiNTQ4MTFiNjU0MTRhNjI4NTYyYmM1LmJpbmRQb3B1cChwb3B1cF8wYjBkMjgxYjFkNzY0MDA0YmY3NTk3OTZhNzYxZjhiNCk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzU1MTNkYjIwYzUyNDQ1MDM4MWRiYTA5ZmM1ZDZkZmRmID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjI5MTYyNjgzMzA4MTk3MjcsIDQ4Ljg5NzU3NTUyNTExMDU1NF0sIFsyLjI5MjQzOTczNTI4Njk2MTQsIDQ4LjkwNzYzNjQwNTYwNDIzXSwgWzIuMjgxMjExNDU2ODUxNjA2LCA0OC45MDc4NTg1MTcyNDQ3OF0sIFsyLjI4MDQwMjUyNzc3Mzg5MTcsIDQ4Ljg5Nzc5NzQ5MDAyNTA4NF1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fNTUxM2RiMjBjNTI0NDUwMzgxZGJhMDlmYzVkNmRmZGYuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfNjk3ZTZmMDdhOWI0NGUzZDkxMWNlNDA4MmFmNDJmYzggPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfNmRmYzU2ZDhmN2E1NDkyOWJmNmZjNTE2N2IzYzMwYTMgPSAkKCc8ZGl2IGlkPSJodG1sXzZkZmM1NmQ4ZjdhNTQ5MjliZjZmYzUxNjdiM2MzMGEzIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NmY3YzwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNjk3ZTZmMDdhOWI0NGUzZDkxMWNlNDA4MmFmNDJmYzguc2V0Q29udGVudChodG1sXzZkZmM1NmQ4ZjdhNTQ5MjliZjZmYzUxNjdiM2MzMGEzKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl81NTEzZGIyMGM1MjQ0NTAzODFkYmEwOWZjNWQ2ZGZkZi5iaW5kUG9wdXAocG9wdXBfNjk3ZTZmMDdhOWI0NGUzZDkxMWNlNDA4MmFmNDJmYzgpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl83ZjBkYzJjZGYzZTQ0ZjMzYmI3ZTRmMjM4ODI2NTI1YyA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4zMjIwMTk4MTI0OTM4OTMsIDQ4Ljg1NjY3ODg5MjcwMjM1XSwgWzIuMzI1MzE0MzM0MjU5MTg1LCA0OC44OTY5MDI3ODk0MDE0NjZdLCBbMi4yODA0MDI1Mjc3NzM4OTE3LCA0OC44OTc3OTc0OTAwMjUwODRdLCBbMi4yNzcxNzE1MDE4ODAxNzksIDQ4Ljg1NzU3MTIzMTc5NTc0NV1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fN2YwZGMyY2RmM2U0NGYzM2JiN2U0ZjIzODgyNjUyNWMuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfNzQ1MWYyMmE3MTYxNGU0Yzg2NGU4MTAyOTJmMmM4MTkgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfZWNkMjU5NTJiNjg5NGViMGIyNTk3OTFmZGUyNjRkNGEgPSAkKCc8ZGl2IGlkPSJodG1sX2VjZDI1OTUyYjY4OTRlYjBiMjU5NzkxZmRlMjY0ZDRhIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NmZjPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF83NDUxZjIyYTcxNjE0ZTRjODY0ZTgxMDI5MmYyYzgxOS5zZXRDb250ZW50KGh0bWxfZWNkMjU5NTJiNjg5NGViMGIyNTk3OTFmZGUyNjRkNGEpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzdmMGRjMmNkZjNlNDRmMzNiYjdlNGYyMzg4MjY1MjVjLmJpbmRQb3B1cChwb3B1cF83NDUxZjIyYTcxNjE0ZTRjODY0ZTgxMDI5MmYyYzgxOSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uX2Y0ZjE3ODBlOTQ2YzQ1NDNhMzhiMzMxM2M4ZTBlZjRhID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjI5Nzk2MjI1NDI5NTU4MSwgNDguODM3MDI1NTEwMDQwMzJdLCBbMi4yOTk1OTA4MDE5NjI0ODAyLCA0OC44NTcxMjczMzcwMzgwMl0sIFsyLjI3NzE3MTUwMTg4MDE3OSwgNDguODU3NTcxMjMxNzk1NzQ1XSwgWzIuMjc1NTU4Nzk3NzU5MDA2LCA0OC44Mzc0Njg4MTg2NTAyNDRdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uX2Y0ZjE3ODBlOTQ2YzQ1NDNhMzhiMzMxM2M4ZTBlZjRhLnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzc0ODkyMjMwMDQ1MjQyMGQ5Y2NlMTJiMTY1YWRhMTQyID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzUwOGVlYTFkMzMwYjQxMTE5ZTIzZTY1YzJkNGQ0ZDMyID0gJCgnPGRpdiBpZD0iaHRtbF81MDhlZWExZDMzMGI0MTExOWUyM2U2NWMyZDRkNGQzMiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjcwMTwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNzQ4OTIyMzAwNDUyNDIwZDljY2UxMmIxNjVhZGExNDIuc2V0Q29udGVudChodG1sXzUwOGVlYTFkMzMwYjQxMTE5ZTIzZTY1YzJkNGQ0ZDMyKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl9mNGYxNzgwZTk0NmM0NTQzYTM4YjMzMTNjOGUwZWY0YS5iaW5kUG9wdXAocG9wdXBfNzQ4OTIyMzAwNDUyNDIwZDljY2UxMmIxNjVhZGExNDIpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl82NTg0MTY3ZWFhZDY0YWZjYThiY2VjZjU4MTY1MDAwOCA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4zMjAzNzU0MTU0MTU5Mzc1LCA0OC44MzY1Nzc2NTc4NDYzXSwgWzIuMzIyMDE5ODEyNDkzODkzLCA0OC44NTY2Nzg4OTI3MDIzNV0sIFsyLjI5OTU5MDgwMTk2MjQ4MDIsIDQ4Ljg1NzEyNzMzNzAzODAyXSwgWzIuMjk3OTYyMjU0Mjk1NTgxLCA0OC44MzcwMjU1MTAwNDAzMl1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fNjU4NDE2N2VhYWQ2NGFmY2E4YmNlY2Y1ODE2NTAwMDguc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfN2U4MWUzNWIzMDk1NGM1MGJlMzY2MmUwZGQ1MzQ2NTEgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMGVhMWJhMWJiY2E0NGE3MWI0OWJmYzU4ZjA0ZmRhM2EgPSAkKCc8ZGl2IGlkPSJodG1sXzBlYTFiYTFiYmNhNDRhNzFiNDliZmM1OGYwNGZkYTNhIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NzAzPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF83ZTgxZTM1YjMwOTU0YzUwYmUzNjYyZTBkZDUzNDY1MS5zZXRDb250ZW50KGh0bWxfMGVhMWJhMWJiY2E0NGE3MWI0OWJmYzU4ZjA0ZmRhM2EpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzY1ODQxNjdlYWFkNjRhZmNhOGJjZWNmNTgxNjUwMDA4LmJpbmRQb3B1cChwb3B1cF83ZTgxZTM1YjMwOTU0YzUwYmUzNjYyZTBkZDUzNDY1MSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzgzMzlhZTNiOGY5ZDRmNDA5NTJmMDNkZjJjNmNjZDQxID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjMwODM1MDA5NzU5MTc4NSwgNDguODI2NzU0MDY2MzI2Nl0sIFsyLjMwOTE2NzYyMjI3MDU1NTUsIDQ4LjgzNjgwMjE1MjI0NTEzXSwgWzIuMjk3OTYyMjU0Mjk1NTgxLCA0OC44MzcwMjU1MTAwNDAzMl0sIFsyLjI5NzE0ODY4ODE3MzY4MjUsIDQ4LjgyNjk3NzI3NjYxNjA2XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl84MzM5YWUzYjhmOWQ0ZjQwOTUyZjAzZGYyYzZjY2Q0MS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF81Zjc5ZWRkMTBkZGE0YjdiYjZkZTgyMTg3MmM4NDMwYSA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9mYzU0ODA1NTQ2MDg0Y2Q5ODNhYmM5MzE4NWQwMzhiMiA9ICQoJzxkaXYgaWQ9Imh0bWxfZmM1NDgwNTU0NjA4NGNkOTgzYWJjOTMxODVkMDM4YjIiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY3MDQ0PC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF81Zjc5ZWRkMTBkZGE0YjdiYjZkZTgyMTg3MmM4NDMwYS5zZXRDb250ZW50KGh0bWxfZmM1NDgwNTU0NjA4NGNkOTgzYWJjOTMxODVkMDM4YjIpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzgzMzlhZTNiOGY5ZDRmNDA5NTJmMDNkZjJjNmNjZDQxLmJpbmRQb3B1cChwb3B1cF81Zjc5ZWRkMTBkZGE0YjdiYjZkZTgyMTg3MmM4NDMwYSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzIyZjNkN2YwNDNkZjQ5ZTZhMmZhMjAzNWEzZGI3NDljID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjMxOTU1MzkzMTQ0ODU5NjUsIDQ4LjgyNjUyOTcyMDE4MjM5XSwgWzIuMzIwMzc1NDE1NDE1OTM3NSwgNDguODM2NTc3NjU3ODQ2M10sIFsyLjMwOTE2NzYyMjI3MDU1NTUsIDQ4LjgzNjgwMjE1MjI0NTEzXSwgWzIuMzA4MzUwMDk3NTkxNzg1LCA0OC44MjY3NTQwNjYzMjY2XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl8yMmYzZDdmMDQzZGY0OWU2YTJmYTIwMzVhM2RiNzQ5Yy5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF83MGZhY2M4MzkwMTU0YmVmOGJjMTRjNWVhYTkwN2MzYiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9hODhjODhmMTZhZTM0M2E0ODhjNmEyYzhjZDg5ZDY1MCA9ICQoJzxkaXYgaWQ9Imh0bWxfYTg4Yzg4ZjE2YWUzNDNhNDg4YzZhMmM4Y2Q4OWQ2NTAiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY3MDRjPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF83MGZhY2M4MzkwMTU0YmVmOGJjMTRjNWVhYTkwN2MzYi5zZXRDb250ZW50KGh0bWxfYTg4Yzg4ZjE2YWUzNDNhNDg4YzZhMmM4Y2Q4OWQ2NTApOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzIyZjNkN2YwNDNkZjQ5ZTZhMmZhMjAzNWEzZGI3NDljLmJpbmRQb3B1cChwb3B1cF83MGZhY2M4MzkwMTU0YmVmOGJjMTRjNWVhYTkwN2MzYik7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzUwZGY1ZWIxZTdjZTRlOTY4ZjAwYzVjNTJlNDkyODU5ID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjI5NzE0ODY4ODE3MzY4MjUsIDQ4LjgyNjk3NzI3NjYxNjA2XSwgWzIuMjk3OTYyMjU0Mjk1NTgxLCA0OC44MzcwMjU1MTAwNDAzMl0sIFsyLjI4Njc1OTMxMjQ2NjgzNjQsIDQ4LjgzNzI0NzczMTkzOTQ1Nl0sIFsyLjI4NTk0OTcwNDE2OTA3OTUsIDQ4LjgyNzE5OTM1MTc1NzkzXV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl81MGRmNWViMWU3Y2U0ZTk2OGYwMGM1YzUyZTQ5Mjg1OS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF83MWUxM2VkNzFlZTg0MDA4YWIyODNlNTNmYWZlNjcxNiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9iOGU3MTQzNjAyYTU0ZWRlOGYyM2FjZDExY2IyZjk1YyA9ICQoJzxkaXYgaWQ9Imh0bWxfYjhlNzE0MzYwMmE1NGVkZThmMjNhY2QxMWNiMmY5NWMiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY3MDZjPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF83MWUxM2VkNzFlZTg0MDA4YWIyODNlNTNmYWZlNjcxNi5zZXRDb250ZW50KGh0bWxfYjhlNzE0MzYwMmE1NGVkZThmMjNhY2QxMWNiMmY5NWMpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzUwZGY1ZWIxZTdjZTRlOTY4ZjAwYzVjNTJlNDkyODU5LmJpbmRQb3B1cChwb3B1cF83MWUxM2VkNzFlZTg0MDA4YWIyODNlNTNmYWZlNjcxNik7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzA3ZTM4OWVmMjdjYTQ4YzI5ZWMzMTRhZjBjMGVjNDhkID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjI4NTk0OTcwNDE2OTA3OTUsIDQ4LjgyNzE5OTM1MTc1NzkzXSwgWzIuMjg2NzU5MzEyNDY2ODM2NCwgNDguODM3MjQ3NzMxOTM5NDU2XSwgWzIuMjc1NTU4Nzk3NzU5MDA2LCA0OC44Mzc0Njg4MTg2NTAyNDRdLCBbMi4yNzQ3NTMxNDY1NTE2MzA0LCA0OC44Mjc0MjAyOTI0NTk0NjVdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzA3ZTM4OWVmMjdjYTQ4YzI5ZWMzMTRhZjBjMGVjNDhkLnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2VkZTViNDMyYzc5ZjQxNjVhNzAwOTRjYTg1ZTFiNGFkID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzMxY2QwZDA1MDM2MjRlNGZiYmEwNWMzNDg1Njc3ZjYxID0gJCgnPGRpdiBpZD0iaHRtbF8zMWNkMGQwNTAzNjI0ZTRmYmJhMDVjMzQ4NTY3N2Y2MSIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjcwNzQ8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2VkZTViNDMyYzc5ZjQxNjVhNzAwOTRjYTg1ZTFiNGFkLnNldENvbnRlbnQoaHRtbF8zMWNkMGQwNTAzNjI0ZTRmYmJhMDVjMzQ4NTY3N2Y2MSk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fMDdlMzg5ZWYyN2NhNDhjMjllYzMxNGFmMGMwZWM0OGQuYmluZFBvcHVwKHBvcHVwX2VkZTViNDMyYzc5ZjQxNjVhNzAwOTRjYTg1ZTFiNGFkKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fMTk2NjZiYjZiNjg5NDg5ZmFiNDYzNTA1MDM5ZGU2YTUgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMzY0MzkzNDkxNzI3NDAwOCwgNDguODI1NjIwOTYyOTE5NjldLCBbMi4zNjUyMzA4MjAxNDUzNTgyLCA0OC44MzU2NjgzMDAwNjczOV0sIFsyLjM1NDAxMzMzNjA5OTI3OTcsIDQ4LjgzNTg5NzM0Nzk1NDA3NF0sIFsyLjM1MzE3OTk2OTg4NjM1NywgNDguODI1ODQ5ODU5NTUxNzldXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzE5NjY2YmI2YjY4OTQ4OWZhYjQ2MzUwNTAzOWRlNmE1LnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2QxMzRlYWQ0YzU0NTQ4ZDg5MjNlNjlmMDA0ZmQ1MjUyID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzUwZDRjZjM4NGQ4OTRmZjdiOGNmODdmZGI3MmQ0ZDM2ID0gJCgnPGRpdiBpZD0iaHRtbF81MGQ0Y2YzODRkODk0ZmY3YjhjZjg3ZmRiNzJkNGQzNiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjcxOGM8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2QxMzRlYWQ0YzU0NTQ4ZDg5MjNlNjlmMDA0ZmQ1MjUyLnNldENvbnRlbnQoaHRtbF81MGQ0Y2YzODRkODk0ZmY3YjhjZjg3ZmRiNzJkNGQzNik7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fMTk2NjZiYjZiNjg5NDg5ZmFiNDYzNTA1MDM5ZGU2YTUuYmluZFBvcHVwKHBvcHVwX2QxMzRlYWQ0YzU0NTQ4ZDg5MjNlNjlmMDA0ZmQ1MjUyKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fODk1MDI4NDM4NTYzNDMwNDliYTU2MzZiNTk1NzliNmQgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMzUzMTc5OTY5ODg2MzU3LCA0OC44MjU4NDk4NTk1NTE3OV0sIFsyLjM1NDAxMzMzNjA5OTI3OTcsIDQ4LjgzNTg5NzM0Nzk1NDA3NF0sIFsyLjM0Mjc5ODI3MzMwODk2MiwgNDguODM2MTI1MjU2NDA4MDQ2XSwgWzIuMzQxOTY4ODY4NTczNTExLCA0OC44MjYwNzc2MTc1MDE4Ml1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fODk1MDI4NDM4NTYzNDMwNDliYTU2MzZiNTk1NzliNmQuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfNTg4NTBiMmRiMTE0NDAzZTllZWQxNWYxNGI4MThkYTUgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfYTBlNzMyMWI5ZmVhNDhlOGJlMDQxNGM1NTliNWI5ZTMgPSAkKCc8ZGl2IGlkPSJodG1sX2EwZTczMjFiOWZlYTQ4ZThiZTA0MTRjNTU5YjViOWUzIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NzE5NDwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNTg4NTBiMmRiMTE0NDAzZTllZWQxNWYxNGI4MThkYTUuc2V0Q29udGVudChodG1sX2EwZTczMjFiOWZlYTQ4ZThiZTA0MTRjNTU5YjViOWUzKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl84OTUwMjg0Mzg1NjM0MzA0OWJhNTYzNmI1OTU3OWI2ZC5iaW5kUG9wdXAocG9wdXBfNTg4NTBiMmRiMTE0NDAzZTllZWQxNWYxNGI4MThkYTUpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl9lZWIxNGZjNDcxYmU0MGVmOWI1MTk3MTZjM2FiZGY0ZiA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4zMzA3NjAxODg3NjgxOTE1LCA0OC44MjYzMDQyMzc0NzY0M10sIFsyLjMzMTU4NTYzMjc1NDc3MTMsIDQ4LjgzNjM1MjAyNjEzNjM4XSwgWzIuMzIwMzc1NDE1NDE1OTM3NSwgNDguODM2NTc3NjU3ODQ2M10sIFsyLjMxOTU1MzkzMTQ0ODU5NjUsIDQ4LjgyNjUyOTcyMDE4MjM5XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9lZWIxNGZjNDcxYmU0MGVmOWI1MTk3MTZjM2FiZGY0Zi5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF85ZjFlMGJjMDBhZDQ0YzJkOTA1NWIwNWI3ZTAzZGJkZiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9mODQ2YzY1MzVkMjA0MGZkYTgyNzUwNTUxMDYxODE5OSA9ICQoJzxkaXYgaWQ9Imh0bWxfZjg0NmM2NTM1ZDIwNDBmZGE4Mjc1MDU1MTA2MTgxOTkiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY3MWI0PC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF85ZjFlMGJjMDBhZDQ0YzJkOTA1NWIwNWI3ZTAzZGJkZi5zZXRDb250ZW50KGh0bWxfZjg0NmM2NTM1ZDIwNDBmZGE4Mjc1MDU1MTA2MTgxOTkpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uX2VlYjE0ZmM0NzFiZTQwZWY5YjUxOTcxNmMzYWJkZjRmLmJpbmRQb3B1cChwb3B1cF85ZjFlMGJjMDBhZDQ0YzJkOTA1NWIwNWI3ZTAzZGJkZik7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzM5NDFmMDM4ZjZhMDQ1ZTM5NDNlYjM3ZTFlZDdjOGY5ID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjM0MTk2ODg2ODU3MzUxMSwgNDguODI2MDc3NjE3NTAxODJdLCBbMi4zNDI3OTgyNzMzMDg5NjIsIDQ4LjgzNjEyNTI1NjQwODA0Nl0sIFsyLjMzMTU4NTYzMjc1NDc3MTMsIDQ4LjgzNjM1MjAyNjEzNjM4XSwgWzIuMzMwNzYwMTg4NzY4MTkxNSwgNDguODI2MzA0MjM3NDc2NDNdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzM5NDFmMDM4ZjZhMDQ1ZTM5NDNlYjM3ZTFlZDdjOGY5LnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzM3MDM0MGIzZDA2YjQ3NWM5ODQ1MjQxMmU5YWM2MmY4ID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzM0NDRjZTlhM2U3NTQ5MmNhZTU3MGI3Y2RkZGY1YjA0ID0gJCgnPGRpdiBpZD0iaHRtbF8zNDQ0Y2U5YTNlNzU0OTJjYWU1NzBiN2NkZGRmNWIwNCIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjcxYmM8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzM3MDM0MGIzZDA2YjQ3NWM5ODQ1MjQxMmU5YWM2MmY4LnNldENvbnRlbnQoaHRtbF8zNDQ0Y2U5YTNlNzU0OTJjYWU1NzBiN2NkZGRmNWIwNCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fMzk0MWYwMzhmNmEwNDVlMzk0M2ViMzdlMWVkN2M4ZjkuYmluZFBvcHVwKHBvcHVwXzM3MDM0MGIzZDA2YjQ3NWM5ODQ1MjQxMmU5YWM2MmY4KTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fZGIyZGQ3ODgwNDQ5NDA3ZmE3YWU3NzZiMGMzYjM2MTcgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMzQyNzk4MjczMzA4OTYyLCA0OC44MzYxMjUyNTY0MDgwNDZdLCBbMi4zNDQ0NTg1MjU2NDY3Njc0LCA0OC44NTYyMjU4OTMxMjE1MDRdLCBbMi4zMjIwMTk4MTI0OTM4OTMsIDQ4Ljg1NjY3ODg5MjcwMjM1XSwgWzIuMzIwMzc1NDE1NDE1OTM3NSwgNDguODM2NTc3NjU3ODQ2M11dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fZGIyZGQ3ODgwNDQ5NDA3ZmE3YWU3NzZiMGMzYjM2MTcuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfYTk1YjM5MzA5NTMwNDkyY2I1NDBkNTU2ZmIxNGYwNjMgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfNDI3OWNhOGZjMmFlNDg4MDg5NmNjYjgyMWI2MTM2YTcgPSAkKCc8ZGl2IGlkPSJodG1sXzQyNzljYThmYzJhZTQ4ODA4OTZjY2I4MjFiNjEzNmE3IiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NzFkPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF9hOTViMzkzMDk1MzA0OTJjYjU0MGQ1NTZmYjE0ZjA2My5zZXRDb250ZW50KGh0bWxfNDI3OWNhOGZjMmFlNDg4MDg5NmNjYjgyMWI2MTM2YTcpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uX2RiMmRkNzg4MDQ0OTQwN2ZhN2FlNzc2YjBjM2IzNjE3LmJpbmRQb3B1cChwb3B1cF9hOTViMzkzMDk1MzA0OTJjYjU0MGQ1NTZmYjE0ZjA2Myk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uX2JkZWMyOTUyNDBiYTRlM2Q4NmUyNjNjNmE3MWFkYTNjID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjM2NTIzMDgyMDE0NTM1ODIsIDQ4LjgzNTY2ODMwMDA2NzM5XSwgWzIuMzY2OTA2OTMzNTc1MjM0LCA0OC44NTU3NjgzMzI2MzAyOF0sIFsyLjM0NDQ1ODUyNTY0Njc2NzQsIDQ4Ljg1NjIyNTg5MzEyMTUwNF0sIFsyLjM0Mjc5ODI3MzMwODk2MiwgNDguODM2MTI1MjU2NDA4MDQ2XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9iZGVjMjk1MjQwYmE0ZTNkODZlMjYzYzZhNzFhZGEzYy5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF8wNWY4ZjkyYTRlZTE0Mzg3ODBkNTdkYTk3NDIwYTg3NiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9iZjg0ZmI3ODg3YWY0NzMyODczM2U2NjljODJkZmZmOSA9ICQoJzxkaXYgaWQ9Imh0bWxfYmY4NGZiNzg4N2FmNDczMjg3MzNlNjY5YzgyZGZmZjkiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY3MWY8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzA1ZjhmOTJhNGVlMTQzODc4MGQ1N2RhOTc0MjBhODc2LnNldENvbnRlbnQoaHRtbF9iZjg0ZmI3ODg3YWY0NzMyODczM2U2NjljODJkZmZmOSk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fYmRlYzI5NTI0MGJhNGUzZDg2ZTI2M2M2YTcxYWRhM2MuYmluZFBvcHVwKHBvcHVwXzA1ZjhmOTJhNGVlMTQzODc4MGQ1N2RhOTc0MjBhODc2KTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fNWY5ZDdjNTk5YmRjNDhmMmI2MDQyMzU3NTUwODAzOWMgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMzg3NjczMDQ4MDc3NjQ3NiwgNDguODM1MjA2NzgzMTY4MTNdLCBbMi4zODkzNjUwMjg0MTUyMDE1LCA0OC44NTUzMDYyMDU1NjU0MV0sIFsyLjM2NjkwNjkzMzU3NTIzNCwgNDguODU1NzY4MzMyNjMwMjhdLCBbMi4zNjUyMzA4MjAxNDUzNTgyLCA0OC44MzU2NjgzMDAwNjczOV1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fNWY5ZDdjNTk5YmRjNDhmMmI2MDQyMzU3NTUwODAzOWMuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfOWQ5ZGEwNzYzNWU4NDg0YWEzZWNkNmMzMDUxMmFmZjcgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfZTE3MmUxZmYyMmRiNDliMjk5ODQyMjZkN2E3NzExZjggPSAkKCc8ZGl2IGlkPSJodG1sX2UxNzJlMWZmMjJkYjQ5YjI5OTg0MjI2ZDdhNzcxMWY4IiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2NzIxPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF85ZDlkYTA3NjM1ZTg0ODRhYTNlY2Q2YzMwNTEyYWZmNy5zZXRDb250ZW50KGh0bWxfZTE3MmUxZmYyMmRiNDliMjk5ODQyMjZkN2E3NzExZjgpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzVmOWQ3YzU5OWJkYzQ4ZjJiNjA0MjM1NzU1MDgwMzljLmJpbmRQb3B1cChwb3B1cF85ZDlkYTA3NjM1ZTg0ODRhYTNlY2Q2YzMwNTEyYWZmNyk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uX2NmYjcxOTYwYzI1MjQxZjM5N2UzODE2MTUyOWJiMGYzID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjM3NTYwOTQzMzExNjE3NSwgNDguODI1MzkwOTI2ODk5MDFdLCBbMi4zNzY0NTA3MjQ0NjU2OTQsIDQ4LjgzNTQzODExMjA0MTAyNV0sIFsyLjM2NTIzMDgyMDE0NTM1ODIsIDQ4LjgzNTY2ODMwMDA2NzM5XSwgWzIuMzY0MzkzNDkxNzI3NDAwOCwgNDguODI1NjIwOTYyOTE5NjldXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uX2NmYjcxOTYwYzI1MjQxZjM5N2UzODE2MTUyOWJiMGYzLnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2QxODNlYTU4ZTI0ZDRlNWJiOGNmYmY1NzkzNzZlOGI2ID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzliNDFmYzU4ZGMzNTQ0NTZiNzA3NzhlMWY3ZDY4M2RkID0gJCgnPGRpdiBpZD0iaHRtbF85YjQxZmM1OGRjMzU0NDU2YjcwNzc4ZTFmN2Q2ODNkZCIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjcyMjQ8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2QxODNlYTU4ZTI0ZDRlNWJiOGNmYmY1NzkzNzZlOGI2LnNldENvbnRlbnQoaHRtbF85YjQxZmM1OGRjMzU0NDU2YjcwNzc4ZTFmN2Q2ODNkZCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fY2ZiNzE5NjBjMjUyNDFmMzk3ZTM4MTYxNTI5YmIwZjMuYmluZFBvcHVwKHBvcHVwX2QxODNlYTU4ZTI0ZDRlNWJiOGNmYmY1NzkzNzZlOGI2KTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fZjYzMTg2NGZhN2RlNDc3NzkzMjE2MGYyOTRkMTllNTEgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMzg2ODI3NzkzMDcxMDc3LCA0OC44MjUxNTk3NTA3ODMzNl0sIFsyLjM4NzY3MzA0ODA3NzY0NzYsIDQ4LjgzNTIwNjc4MzE2ODEzXSwgWzIuMzc2NDUwNzI0NDY1Njk0LCA0OC44MzU0MzgxMTIwNDEwMjVdLCBbMi4zNzU2MDk0MzMxMTYxNzUsIDQ4LjgyNTM5MDkyNjg5OTAxXV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9mNjMxODY0ZmE3ZGU0Nzc3OTMyMTYwZjI5NGQxOWU1MS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF80MWJjNjFmMTc0Nzk0ZGMwYjEzMGE4NjEyZThiYTM3NSA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9jZGRlODI3MWRhNzk0MTg3OGM0NWUzNDA4Yjk4NDViNCA9ICQoJzxkaXYgaWQ9Imh0bWxfY2RkZTgyNzFkYTc5NDE4NzhjNDVlMzQwOGI5ODQ1YjQiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY3MjNjPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF80MWJjNjFmMTc0Nzk0ZGMwYjEzMGE4NjEyZThiYTM3NS5zZXRDb250ZW50KGh0bWxfY2RkZTgyNzFkYTc5NDE4NzhjNDVlMzQwOGI5ODQ1YjQpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uX2Y2MzE4NjRmYTdkZTQ3Nzc5MzIxNjBmMjk0ZDE5ZTUxLmJpbmRQb3B1cChwb3B1cF80MWJjNjFmMTc0Nzk0ZGMwYjEzMGE4NjEyZThiYTM3NSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzQyYTQ3ZTEzYjA3MzQyOWY4MzNmMzE3ZWE3YjQ1NDFlID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjM5ODA0ODU3MDYwOTM2OTMsIDQ4LjgyNDkyNzQzMzg2NjQzNV0sIFsyLjM5ODg5Nzc4OTk5NzQ0MDYsIDQ4LjgzNDk3NDMxMjc0MjAyXSwgWzIuMzg3NjczMDQ4MDc3NjQ3NiwgNDguODM1MjA2NzgzMTY4MTNdLCBbMi4zODY4Mjc3OTMwNzEwNzcsIDQ4LjgyNTE1OTc1MDc4MzM2XV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl80MmE0N2UxM2IwNzM0MjlmODMzZjMxN2VhN2I0NTQxZS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9iZmUzNmNjNzcyZmM0ZjhlYWFmOTk1N2M5NmQwNWRmNyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9kZGY1ZWQyYzc1Yzk0Njk4OTMzZGVhM2Y5Y2E1NDVhYiA9ICQoJzxkaXYgaWQ9Imh0bWxfZGRmNWVkMmM3NWM5NDY5ODkzM2RlYTNmOWNhNTQ1YWIiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY3MjQ0PC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF9iZmUzNmNjNzcyZmM0ZjhlYWFmOTk1N2M5NmQwNWRmNy5zZXRDb250ZW50KGh0bWxfZGRmNWVkMmM3NWM5NDY5ODkzM2RlYTNmOWNhNTQ1YWIpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzQyYTQ3ZTEzYjA3MzQyOWY4MzNmMzE3ZWE3YjQ1NDFlLmJpbmRQb3B1cChwb3B1cF9iZmUzNmNjNzcyZmM0ZjhlYWFmOTk1N2M5NmQwNWRmNyk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzMzN2Q5NWY4Yjc5ZjQ1NDZhOWY3ZmZiMzhiNjdkZTY0ID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjQwOTI3MTc2NDc0NzE3OCwgNDguODI0NjkzOTc1NDQyMTE2XSwgWzIuNDEwMTI0OTQ5MjQwMTYwNCwgNDguODM0NzQwNzAwMDU2MDk1XSwgWzIuMzk4ODk3Nzg5OTk3NDQwNiwgNDguODM0OTc0MzEyNzQyMDJdLCBbMi4zOTgwNDg1NzA2MDkzNjkzLCA0OC44MjQ5Mjc0MzM4NjY0MzVdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzMzN2Q5NWY4Yjc5ZjQ1NDZhOWY3ZmZiMzhiNjdkZTY0LnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzA3MGMwM2IyMmRjYTRjN2VhOTA1YzEyYjliYjFjZTQwID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzNhZTg4ZDY0YjFlYjQwZjg5NmJmYzBlMzgwNjgwYzExID0gJCgnPGRpdiBpZD0iaHRtbF8zYWU4OGQ2NGIxZWI0MGY4OTZiZmMwZTM4MDY4MGMxMSIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjcyNWM8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzA3MGMwM2IyMmRjYTRjN2VhOTA1YzEyYjliYjFjZTQwLnNldENvbnRlbnQoaHRtbF8zYWU4OGQ2NGIxZWI0MGY4OTZiZmMwZTM4MDY4MGMxMSk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fMzM3ZDk1ZjhiNzlmNDU0NmE5ZjdmZmIzOGI2N2RlNjQuYmluZFBvcHVwKHBvcHVwXzA3MGMwM2IyMmRjYTRjN2VhOTA1YzEyYjliYjFjZTQwKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fY2JkNGRmNTBhZDhiNGViMDkzMjZjMzYzMzQ4Nzk5OTMgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuNDEwMTI0OTQ5MjQwMTYwNCwgNDguODM0NzQwNzAwMDU2MDk1XSwgWzIuNDExODMyODAyMjg0MzU1NCwgNDguODU0ODM5NTA2MjY1NjhdLCBbMi4zODkzNjUwMjg0MTUyMDE1LCA0OC44NTUzMDYyMDU1NjU0MV0sIFsyLjM4NzY3MzA0ODA3NzY0NzYsIDQ4LjgzNTIwNjc4MzE2ODEzXV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9jYmQ0ZGY1MGFkOGI0ZWIwOTMyNmMzNjMzNDg3OTk5My5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9iNGRjYjEyM2YwMzM0N2NkOTU3NmQ2ODI1ZTc1MzRkMiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9kM2E1Zjc0M2NjMzY0ZTNiOTU1YWExNDU5MzQ0OGFmOSA9ICQoJzxkaXYgaWQ9Imh0bWxfZDNhNWY3NDNjYzM2NGUzYjk1NWFhMTQ1OTM0NDhhZjkiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY3Mjc8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2I0ZGNiMTIzZjAzMzQ3Y2Q5NTc2ZDY4MjVlNzUzNGQyLnNldENvbnRlbnQoaHRtbF9kM2E1Zjc0M2NjMzY0ZTNiOTU1YWExNDU5MzQ0OGFmOSk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fY2JkNGRmNTBhZDhiNGViMDkzMjZjMzYzMzQ4Nzk5OTMuYmluZFBvcHVwKHBvcHVwX2I0ZGNiMTIzZjAzMzQ3Y2Q5NTc2ZDY4MjVlNzUzNGQyKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fZTk5ZmE1Nzk5MjY0NDBmYWI1YmRhMmM1YTZhNmFlNzEgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMjYzNTU5MDE2MjkzODU1NSwgNDguODI3NjQwMDk5NDI4MDJdLCBbMi4yNjQzNjA3MTExNDU2MzksIDQ4LjgzNzY4ODc3MDg4MDUwNF0sIFsyLjI1MzE2NTA1MzU5OTE0ODMsIDQ4LjgzNzkwNzU4OTMzODE4XSwgWzIuMjUyMzY3MzE0MzY3MTQwOCwgNDguODI3ODU4NzczMzcxMTFdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uX2U5OWZhNTc5OTI2NDQwZmFiNWJkYTJjNWE2YTZhZTcxLnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2Y5YzBlMTE1YWY5ZTRiMWZhOWVkY2RkNmMzOGRjZDFkID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2VlNDdhMTdjOGRmODQyODY5Zjg1YjhlZThlYzI5ZTlkID0gJCgnPGRpdiBpZD0iaHRtbF9lZTQ3YTE3YzhkZjg0Mjg2OWY4NWI4ZWU4ZWMyOWU5ZCIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjdhOTQ8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2Y5YzBlMTE1YWY5ZTRiMWZhOWVkY2RkNmMzOGRjZDFkLnNldENvbnRlbnQoaHRtbF9lZTQ3YTE3YzhkZjg0Mjg2OWY4NWI4ZWU4ZWMyOWU5ZCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fZTk5ZmE1Nzk5MjY0NDBmYWI1YmRhMmM1YTZhNmFlNzEuYmluZFBvcHVwKHBvcHVwX2Y5YzBlMTE1YWY5ZTRiMWZhOWVkY2RkNmMzOGRjZDFkKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fMWQ5YzgyMTNjODk2NGUwZDhkMWM4YmZjNzQ2OTYwNmUgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMjc0NzUzMTQ2NTUxNjMwNCwgNDguODI3NDIwMjkyNDU5NDY1XSwgWzIuMjc1NTU4Nzk3NzU5MDA2LCA0OC44Mzc0Njg4MTg2NTAyNDRdLCBbMi4yNjQzNjA3MTExNDU2MzksIDQ4LjgzNzY4ODc3MDg4MDUwNF0sIFsyLjI2MzU1OTAxNjI5Mzg1NTUsIDQ4LjgyNzY0MDA5OTQyODAyXV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl8xZDljODIxM2M4OTY0ZTBkOGQxYzhiZmM3NDY5NjA2ZS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9jZjA2OTA1NGQxNzI0MTAzOTQxYzM1Y2JlMTRhNjdkNyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF83MDNkNDFjMzhjOTM0Y2NjODhhMWE5YjczNmFlYjlkZCA9ICQoJzxkaXYgaWQ9Imh0bWxfNzAzZDQxYzM4YzkzNGNjYzg4YTFhOWI3MzZhZWI5ZGQiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY3YTljPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF9jZjA2OTA1NGQxNzI0MTAzOTQxYzM1Y2JlMTRhNjdkNy5zZXRDb250ZW50KGh0bWxfNzAzZDQxYzM4YzkzNGNjYzg4YTFhOWI3MzZhZWI5ZGQpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGdlb19qc29uXzFkOWM4MjEzYzg5NjRlMGQ4ZDFjOGJmYzc0Njk2MDZlLmJpbmRQb3B1cChwb3B1cF9jZjA2OTA1NGQxNzI0MTAzOTQxYzM1Y2JlMTRhNjdkNyk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgdmFyIGdlb19qc29uXzk4NDVlMDk1MDA1ZDRkM2U5NTc5MTA0NTVkMzk2ZWVlID0gTC5nZW9Kc29uKAogICAgICAgICAgICAgICAgICAgIHsiZmVhdHVyZXMiOiBbeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1syLjI3NTU1ODc5Nzc1OTAwNiwgNDguODM3NDY4ODE4NjUwMjQ0XSwgWzIuMjc3MTcxNTAxODgwMTc5LCA0OC44NTc1NzEyMzE3OTU3NDVdLCBbMi4yNTQ3NjE5MjAwNTY0MjYsIDQ4Ljg1ODAxMDU4MjY0NDY4XSwgWzIuMjUzMTY1MDUzNTk5MTQ4MywgNDguODM3OTA3NTg5MzM4MThdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzk4NDVlMDk1MDA1ZDRkM2U5NTc5MTA0NTVkMzk2ZWVlLnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzZhMWIwZWU4OWZhNDRhZTViMGFjNWE1ZGEwM2Q5YThlID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzdjNTVmYjM2MGIwMjQxNmViNzhlMmZkNTA4NzJhMTA5ID0gJCgnPGRpdiBpZD0iaHRtbF83YzU1ZmIzNjBiMDI0MTZlYjc4ZTJmZDUwODcyYTEwOSIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjdhYjwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNmExYjBlZTg5ZmE0NGFlNWIwYWM1YTVkYTAzZDlhOGUuc2V0Q29udGVudChodG1sXzdjNTVmYjM2MGIwMjQxNmViNzhlMmZkNTA4NzJhMTA5KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl85ODQ1ZTA5NTAwNWQ0ZDNlOTU3OTEwNDU1ZDM5NmVlZS5iaW5kUG9wdXAocG9wdXBfNmExYjBlZTg5ZmE0NGFlNWIwYWM1YTVkYTAzZDlhOGUpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl9kMDQ5MDk4ZjMzNDE0M2Q2ODJiNzdlOWEyNzgyM2NmYSA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4yNTMxNjUwNTM1OTkxNDgzLCA0OC44Mzc5MDc1ODkzMzgxOF0sIFsyLjI1NDc2MTkyMDA1NjQyNiwgNDguODU4MDEwNTgyNjQ0NjhdLCBbMi4yMzIzNjIwNjQyODI0NDcsIDQ4Ljg1ODQ0NTM5NTI1NTkxXSwgWzIuMjMwNzgxMDI5NTkwNzcsIDQ4LjgzODM0MTgyNzc2ODEyXV1dLCAidHlwZSI6ICJQb2x5Z29uIn0sICJwcm9wZXJ0aWVzIjogeyJoaWdobGlnaHQiOiB7fSwgInN0eWxlIjogeyJmaWxsQ29sb3IiOiAiI2VlYTUwMCIsICJ3ZWlnaHQiOiAxfX0sICJ0eXBlIjogIkZlYXR1cmUifV0sICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIn0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF84ZGEzM2VkNDI0YjY0NjgzOTFiZGJkMDYzNDJhYmVjNik7CiAgICAgICAgICAgICAgICBnZW9fanNvbl9kMDQ5MDk4ZjMzNDE0M2Q2ODJiNzdlOWEyNzgyM2NmYS5zZXRTdHlsZShmdW5jdGlvbihmZWF0dXJlKSB7cmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTt9KTsKCiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF85ZDVmYzAzNzQ4ZTU0MmI4YWM4NTZiMmYyOGJjOWU1MyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF8wOGM0NWFlYjhjNTQ0NTUwODM3YTRhOTY3MjgxYTc2NyA9ICQoJzxkaXYgaWQ9Imh0bWxfMDhjNDVhZWI4YzU0NDU1MDgzN2E0YTk2NzI4MWE3NjciIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQ3ZTY3YWQ8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzlkNWZjMDM3NDhlNTQyYjhhYzg1NmIyZjI4YmM5ZTUzLnNldENvbnRlbnQoaHRtbF8wOGM0NWFlYjhjNTQ0NTUwODM3YTRhOTY3MjgxYTc2Nyk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fZDA0OTA5OGYzMzQxNDNkNjgyYjc3ZTlhMjc4MjNjZmEuYmluZFBvcHVwKHBvcHVwXzlkNWZjMDM3NDhlNTQyYjhhYzg1NmIyZjI4YmM5ZTUzKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fNjI3YzY4ZTNiNzQyNGJhNDgwMTg4YjI3YmIxNmU1ZmUgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMjQxMTc4MDQxNzQxNzM2NCwgNDguODI4MDc2MzE0OTk2MzddLCBbMi4yNDE5NzE4MjYwOTA4MTIsIDQ4LjgzODEyNTI3NDczMTMyXSwgWzIuMjMwNzgxMDI5NTkwNzcsIDQ4LjgzODM0MTgyNzc2ODEyXSwgWzIuMjI5OTkxMTk5Mzg2NzU5NiwgNDguODI4MjkyNzI1MDExNTJdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzYyN2M2OGUzYjc0MjRiYTQ4MDE4OGIyN2JiMTZlNWZlLnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzdhNGNkMGVkNmYzZjRjYjU5OGQ5NmM0MWFhZGRhMWQ4ID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzMwODc5ZTI4YTJhMjRlMGFhMjhiMjc3YWI2MWI5MWE2ID0gJCgnPGRpdiBpZD0iaHRtbF8zMDg3OWUyOGEyYTI0ZTBhYTI4YjI3N2FiNjFiOTFhNiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjdhZTQ8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzdhNGNkMGVkNmYzZjRjYjU5OGQ5NmM0MWFhZGRhMWQ4LnNldENvbnRlbnQoaHRtbF8zMDg3OWUyOGEyYTI0ZTBhYTI4YjI3N2FiNjFiOTFhNik7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fNjI3YzY4ZTNiNzQyNGJhNDgwMTg4YjI3YmIxNmU1ZmUuYmluZFBvcHVwKHBvcHVwXzdhNGNkMGVkNmYzZjRjYjU5OGQ5NmM0MWFhZGRhMWQ4KTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fMjE3NjIwMjEwY2U5NGE3ZWE2YmZjODI4YWEzZWMxMWIgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMjUyMzY3MzE0MzY3MTQwOCwgNDguODI3ODU4NzczMzcxMTFdLCBbMi4yNTMxNjUwNTM1OTkxNDgzLCA0OC44Mzc5MDc1ODkzMzgxOF0sIFsyLjI0MTk3MTgyNjA5MDgxMiwgNDguODM4MTI1Mjc0NzMxMzJdLCBbMi4yNDExNzgwNDE3NDE3MzY0LCA0OC44MjgwNzYzMTQ5OTYzN11dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fMjE3NjIwMjEwY2U5NGE3ZWE2YmZjODI4YWEzZWMxMWIuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfMzgxMjI3OGZkN2JlNGU4ZWFmNThlMmZkZGMwMzU0ODIgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfNDUzMWVhMzExMzkxNGJjYTkyMzkxNDA0NTk5OTQ0NGMgPSAkKCc8ZGl2IGlkPSJodG1sXzQ1MzFlYTMxMTM5MTRiY2E5MjM5MTQwNDU5OTk0NDRjIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2N2FlYzwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfMzgxMjI3OGZkN2JlNGU4ZWFmNThlMmZkZGMwMzU0ODIuc2V0Q29udGVudChodG1sXzQ1MzFlYTMxMTM5MTRiY2E5MjM5MTQwNDU5OTk0NDRjKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl8yMTc2MjAyMTBjZTk0YTdlYTZiZmM4MjhhYTNlYzExYi5iaW5kUG9wdXAocG9wdXBfMzgxMjI3OGZkN2JlNGU4ZWFmNThlMmZkZGMwMzU0ODIpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl81YjVkMDBhODUxNzU0ZTA0YjgyYmVjZDFlMDgzMWUwMiA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4yMjk5OTExOTkzODY3NTk2LCA0OC44MjgyOTI3MjUwMTE1Ml0sIFsyLjIzMDc4MTAyOTU5MDc3LCA0OC44MzgzNDE4Mjc3NjgxMl0sIFsyLjIxOTU5MjY2NTA2ODAzMDQsIDQ4LjgzODU1NzI0OTE1Njg4XSwgWzIuMjE4ODA2Nzg4MjcwMTkyLCA0OC44Mjg1MDgwMDQxMjQ0NF1dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fNWI1ZDAwYTg1MTc1NGUwNGI4MmJlY2QxZTA4MzFlMDIuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfMzc1MzI0YzU1MDViNDQ1YWIxYzIwYmIxNTM3ZGUzMjIgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfYjk0MjgxZGZiOTZkNGVjNzlhY2Y4MjQyZTU4ZDE5ZmEgPSAkKCc8ZGl2IGlkPSJodG1sX2I5NDI4MWRmYjk2ZDRlYzc5YWNmODI0MmU1OGQxOWZhIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2N2IxYzwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfMzc1MzI0YzU1MDViNDQ1YWIxYzIwYmIxNTM3ZGUzMjIuc2V0Q29udGVudChodG1sX2I5NDI4MWRmYjk2ZDRlYzc5YWNmODI0MmU1OGQxOWZhKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl81YjVkMDBhODUxNzU0ZTA0YjgyYmVjZDFlMDgzMWUwMi5iaW5kUG9wdXAocG9wdXBfMzc1MzI0YzU1MDViNDQ1YWIxYzIwYmIxNTM3ZGUzMjIpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHZhciBnZW9fanNvbl82NGMxM2I4NzIyNDA0ZGNkOTU4YjhiZjdkZjE3ODQwZSA9IEwuZ2VvSnNvbigKICAgICAgICAgICAgICAgICAgICB7ImZlYXR1cmVzIjogW3siZ2VvbWV0cnkiOiB7ImNvb3JkaW5hdGVzIjogW1tbMi4yMzA3ODEwMjk1OTA3NywgNDguODM4MzQxODI3NzY4MTJdLCBbMi4yMzE1NzEzMTc3NjMxMzM4LCA0OC44NDgzOTI3MTc5ODE1MjVdLCBbMi4yMjAzNzg5OTc1NTAzNjA3LCA0OC44NDg2MDgyODE3NDU3XSwgWzIuMjE5NTkyNjY1MDY4MDMwNCwgNDguODM4NTU3MjQ5MTU2ODhdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgInByb3BlcnRpZXMiOiB7ImhpZ2hsaWdodCI6IHt9LCAic3R5bGUiOiB7ImZpbGxDb2xvciI6ICIjZWVhNTAwIiwgIndlaWdodCI6IDF9fSwgInR5cGUiOiAiRmVhdHVyZSJ9XSwgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24ifQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzhkYTMzZWQ0MjRiNjQ2ODM5MWJkYmQwNjM0MmFiZWM2KTsKICAgICAgICAgICAgICAgIGdlb19qc29uXzY0YzEzYjg3MjI0MDRkY2Q5NThiOGJmN2RmMTc4NDBlLnNldFN0eWxlKGZ1bmN0aW9uKGZlYXR1cmUpIHtyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO30pOwoKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2E0NmUyOWRiZGUzYjRiMjBiNzE1MjcwMDI4YzI1NzBmID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2M5YWIyYzM0NThkMjRlMTc4ZTU0MmE3ZmRlNTNiYmJjID0gJCgnPGRpdiBpZD0iaHRtbF9jOWFiMmMzNDU4ZDI0ZTE3OGU1NDJhN2ZkZTUzYmJiYyIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NDdlNjdiMjQ8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2E0NmUyOWRiZGUzYjRiMjBiNzE1MjcwMDI4YzI1NzBmLnNldENvbnRlbnQoaHRtbF9jOWFiMmMzNDU4ZDI0ZTE3OGU1NDJhN2ZkZTUzYmJiYyk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgZ2VvX2pzb25fNjRjMTNiODcyMjQwNGRjZDk1OGI4YmY3ZGYxNzg0MGUuYmluZFBvcHVwKHBvcHVwX2E0NmUyOWRiZGUzYjRiMjBiNzE1MjcwMDI4YzI1NzBmKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgZ2VvX2pzb25fMzIwOTU1YzM4MWQzNGI4MmIzMDU0ZDY2NzAyODAxYWEgPSBMLmdlb0pzb24oCiAgICAgICAgICAgICAgICAgICAgeyJmZWF0dXJlcyI6IFt7Imdlb21ldHJ5IjogeyJjb29yZGluYXRlcyI6IFtbWzIuMjMxNTcxMzE3NzYzMTMzOCwgNDguODQ4MzkyNzE3OTgxNTI1XSwgWzIuMjMyMzYyMDY0MjgyNDQ3LCA0OC44NTg0NDUzOTUyNTU5MV0sIFsyLjIyMTE2NTc4NjA5MzkwMjUsIDQ4Ljg1ODY2MTEwMTQ5NTEzXSwgWzIuMjIwMzc4OTk3NTUwMzYwNywgNDguODQ4NjA4MjgxNzQ1N11dXSwgInR5cGUiOiAiUG9seWdvbiJ9LCAicHJvcGVydGllcyI6IHsiaGlnaGxpZ2h0Ijoge30sICJzdHlsZSI6IHsiZmlsbENvbG9yIjogIiNlZWE1MDAiLCAid2VpZ2h0IjogMX19LCAidHlwZSI6ICJGZWF0dXJlIn1dLCAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiJ9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAgICAgZ2VvX2pzb25fMzIwOTU1YzM4MWQzNGI4MmIzMDU0ZDY2NzAyODAxYWEuc2V0U3R5bGUoZnVuY3Rpb24oZmVhdHVyZSkge3JldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7fSk7CgogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfYjc5MWEzNmQxYzU4NGQ4MDhhZjI0Y2Q5MmZkOGQ3NTAgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMjM5ZWNlZjZmMWZhNDg2MGJkMWJlOGRhYWZjZGZmOTAgPSAkKCc8ZGl2IGlkPSJodG1sXzIzOWVjZWY2ZjFmYTQ4NjBiZDFiZThkYWFmY2RmZjkwIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40N2U2N2IyYzwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfYjc5MWEzNmQxYzU4NGQ4MDhhZjI0Y2Q5MmZkOGQ3NTAuc2V0Q29udGVudChodG1sXzIzOWVjZWY2ZjFmYTQ4NjBiZDFiZThkYWFmY2RmZjkwKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBnZW9fanNvbl8zMjA5NTVjMzgxZDM0YjgyYjMwNTRkNjY3MDI4MDFhYS5iaW5kUG9wdXAocG9wdXBfYjc5MWEzNmQxYzU4NGQ4MDhhZjI0Y2Q5MmZkOGQ3NTApOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgICAgIHZhciBwb2x5X2xpbmVfYjI0ZmQwOTQ3M2NlNDliOWJhNWMwZTM4OTIwZmQxM2MgPSBMLnBvbHlsaW5lKAogICAgICAgICAgICAgICAgICAgIFtbNDguODMxNzc2LCAyLjIyMjYzOV0sIFs0OC44MzE3NzYsIDIuNDA2XSwgWzQ4LjkwMjgzOSwgMi40MDZdLCBbNDguOTAyODM5LCAyLjIyMjYzOV0sIFs0OC44MzE3NzYsIDIuMjIyNjM5XV0sCiAgICAgICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiBmYWxzZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAibm9DbGlwIjogZmFsc2UsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInNtb290aEZhY3RvciI6IDEuMCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMgp9KS5hZGRUbyhtYXBfOGRhMzNlZDQyNGI2NDY4MzkxYmRiZDA2MzQyYWJlYzYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfYmM4MTk5ODMzYzQ2NDAzZWIxNzdkN2VkZGI2OGE2NmMgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfNmUxYjQ3NzQyODEyNDgxZTg0Njg5Yjc1NWIzYzU1NTMgPSAkKCc8ZGl2IGlkPSJodG1sXzZlMWI0Nzc0MjgxMjQ4MWU4NDY4OWI3NTViM2M1NTUzIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5zaGFwZTwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfYmM4MTk5ODMzYzQ2NDAzZWIxNzdkN2VkZGI2OGE2NmMuc2V0Q29udGVudChodG1sXzZlMWI0Nzc0MjgxMjQ4MWU4NDY4OWI3NTViM2M1NTUzKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBwb2x5X2xpbmVfYjI0ZmQwOTQ3M2NlNDliOWJhNWMwZTM4OTIwZmQxM2MuYmluZFBvcHVwKHBvcHVwX2JjODE5OTgzM2M0NjQwM2ViMTc3ZDdlZGRiNjhhNjZjKTsKCiAgICAgICAgICAgIAogICAgICAgIAo8L3NjcmlwdD4=" style="position:absolute;width:100%;height:100%;left:0;top:0;border:none !important;" allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe></div></div> 

<p>And here is the resulting <a href="https://nbviewer.jupyter.org/gist/akhenakh/142ddeec4cd7138b517579b4f4b1063f/s2%20python.ipynb">Jupyter notebook</a></p>

                    </div>
                </section>
                
                <h1 class="content-subhead">08 Mar 2016, 11:23</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.nobugware.com/post/2016/geo_db_s2_region_polygon_optmization/" class="post-title">A geo database for polygons, optimization</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Geo" href="https://blog.nobugware.com/categories/geo">Geo</a><a class="post-category post-category-Golang" href="https://blog.nobugware.com/categories/golang">Golang</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>If you read this blog, you know I&rsquo;ve recently released a project called <a href="https://github.com/akhenakh/regionagogo">regionagogo</a>, a geo shape lookup database, described in <a href="https://blog.nobugware.com/post/2016/geo_db_s2_region_polygon/">this blogpost</a>.</p>

<p>It uses the current <a href="https://godoc.org/github.com/golang/geo/s2">Go S2 implementation</a>, which is not yet as complete as the C++ implementation, for example the region coverer of a shape does not really compute cell around the shape but around the bounding box instead.</p>

<p>Using the shape of the polygon makes the covered cells more precise and smaller, resulting at the end to less <a href="https://en.wikipedia.org/wiki/Point_in_polygon">PIP</a> tests which are costly.</p>

<p><img src="https://blog.nobugware.com/img/s2cpp.jpg" alt="S2 over a shape" title="S2 cover" /><br />
The same coverage with Go S2 would have returned 8 big cells of the same size, covering over regions.</p>

<p>I&rsquo;ve created <a href="https://github.com/akhenakh/regionagogogen">regionagogogen</a> a quick and dirty command line program for OSX that takes a GeoJSON file containing your regions and then compute the database using the S2 C++ implementation, it&rsquo;s for OSX only cause I&rsquo;m using ObjC as a bridge to C++ which I don&rsquo;t know enough.</p>

<p>Also note that <a href="https://github.com/akhenakh/regionagogogen">regionagogogen</a> includes an S2 port that works on iOS/OSX and some ObjC geo helper classes.</p>

<p>The <a href="https://hub.docker.com/r/akhenakh/regionagogo/">Docker image fore regionagogo</a> is also using the optimized database.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">18 Feb 2016, 17:16</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.nobugware.com/post/2016/geo_db_s2_region_polygon/" class="post-title">A geo database for polygons, foundations</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Geo" href="https://blog.nobugware.com/categories/geo">Geo</a><a class="post-category post-category-Golang" href="https://blog.nobugware.com/categories/golang">Golang</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<p>On a previous post, <a href="http://blog.nobugware.com/post/2016/geo_db_s2_geohash_database/">I&rsquo;ve described how to use the S2 geo library</a> to create a fast geo database, but it was to store locations (points) and only to perform range queries, a complete geo database would have regions/polygons queries.</p>

<h2 id="looking-for-a-solution">Looking for a solution</h2>

<p>I had this need: querying for the countries or subregions of hundreds of coordinates per second, without relying on an external service.</p>

<p>One solution, using my previous technique, could have been to store every cities in the world and then perform a proximity query around my point to get the closest cities, but it works only in populated area and it&rsquo;s only an approximation.</p>

<p>I looked into others solutions, there is some smart ideas <a href="https://github.com/hlaw/codegrid-js">using UTF-grid</a>, but it&rsquo;s a client side solution and also an approximation tied to the resolution of the computed grid.</p>

<h2 id="s2-to-the-rescue">S2 to the rescue</h2>

<p>S2 cells have some nice properties, they are segments on the <a href="https://en.wikipedia.org/wiki/Hilbert_curve">Hilbert curve</a>, expressed as range of <code>uint64</code>, so I had the intuition the problem to perform fast region lookup could be simplified as find all mathematical segments containing my location expressed as an <code>uint64</code>.</p>

<p><img src="https://blog.nobugware.com/img/s2belgium.jpg" alt="S2 over a country" title="S2 covering belgium" /></p>

<p>Using a <a href="https://en.wikipedia.org/wiki/Segment_tree">Segment Tree</a> datastructure, I first tried an in memory engine, using <a href="http://www.naturalearthdata.com/">Natural Earth Data</a>, loading the whole world countries shapes into S2 loops (a <code>Loop</code> represents a simple spherical polygon), transforming then into cells using the region coverer, it returns cells of different levels, add them to the segment tree.</p>

<p><img src="https://blog.nobugware.com/img/stree.gif" alt="Segment Tree" title="Segment tree picture fron Wikipedia" /></p>

<p>To query, simply tranform the location into an S2 <code>Cell</code> (level 30) and perform a stubbing query that intersects the segments, every segments crossed are cells that covered a part of a <code>Loop</code>.<br />
It will reduce the problem to test a few <code>Loop</code> vs thousands of them, finally perform <code>ContainsPoint</code> against the found loops cause the point could be inside the <code>Cell</code> but not inside the <code>Loop</code> itself.</p>

<p>Et voilà! It works!</p>

<p>The segment tree structure itself is very low on memory, the loops/polygons data could be stored on disk and loaded on requests, I&rsquo;ve tested a second implementation using LevelDB using this technique.</p>

<p>If you have a very large tree (for example cities limits for the whole world), you can even put the segment tree on a KV storage, using this paper <a href="http://students.ceid.upatras.gr/~patlakas/papers/ICDE13_conf_full_420.pdf">Interval Indexing and Querying on Key-Value Cloud Stores</a>.</p>

<h2 id="region-a-gogo">Region a gogo</h2>

<p>As a demonstration here is a working microservice called <a href="https://github.com/akhenakh/regionagogo">regionagogo</a>, simply returning the country &amp; state for a given location.<br />
It loads geo data for the whole world and answers to HTTP queries using small amout of memory.</p>

<pre><code>GET /country?lat=19.542915&amp;lng=-155.665857

{
    &quot;code&quot;: &quot;US&quot;,
    &quot;name&quot;: &quot;Hawaii&quot;
}
</code></pre>

<p>Here is a <a href="https://hub.docker.com/r/akhenakh/regionagogo/">Docker image</a> so you can deploy it on your stack.</p>

<p>Note that it performs really well but can be improved a lot, for example the actual Go S2 implementation is still using Rect boxing around loops, that&rsquo;s why <a href="https://github.com/akhenakh/regionagogo">regionagogo</a> is using a data file so it can be generated from the C++ version.</p>

<h2 id="future">Future</h2>

<p>This technique seems to work well for stubbing queries, region queries, geofencing &hellip;<br />
It can be a solid foundation to create a flexible and simple geo database.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">26 Jan 2016, 14:01</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.nobugware.com/post/2016/geo_db_s2_geohash_database/" class="post-title">A fast geo database with Google S2 take #2</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Geo" href="https://blog.nobugware.com/categories/geo">Geo</a><a class="post-category post-category-Golang" href="https://blog.nobugware.com/categories/golang">Golang</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<p>Six months ago, I wrote on this blog about <a href="https://blog.nobugware.com/post/2015/leveldb_geohash_golang/">Geohashes and LevelDB with Go</a>, to create a fast geo database.<br />
This post is very similar as it works the same way but replacing GeoHashes with <a href="http://blog.christianperone.com/2015/08/googles-s2-geometry-on-the-sphere-cells-and-hilbert-curve/">Google S2</a> library for better performances.</p>

<p>There is an <a href="https://github.com/golang/geo">S2 Golang implementation maintened by Google</a> not as complete as the C++ one but close.</p>

<p>For the storage this post will stay agnostic to avoid any troll, but it applies to any Key Value storages: LevelDB/RocksDB, LMDB, Redis&hellip;<br />
I personnaly use <a href="https://github.com/boltdb/bolt">BoltDB</a> and <a href="https://github.com/steveyen/gtreap">gtreap</a> for my experimentations.</p>

<p>This post will focus on Go usage but can be applied to any languages.</p>

<p>Or skip to the images below for visual explanations.</p>

<h2 id="why-not-geohash">Why not Geohash?</h2>

<p>Geohash is a great solution to perform geo coordinates queries but the way it works can sometimes be an issue with your data.</p>

<ul>
<li><p>Remember geohashes are cells of 12 different widths from 5000km to 3.7cm, when you perform a lookup around a position, if your position is close to a cell&rsquo;s edge you could miss some points from the adjacent cell, that&rsquo;s why you have to query for the 8 neightbour cells, it means 9 range queries into your DB to find all the closest points from your location.</p></li>

<li><p>If your lookup does not fit in level <code>4</code> 39km by 19.5km, the next level is 156km by 156km!</p></li>

<li><p>The query is not performed around your coordinates, you search for the cell you are in then you query for the adjacent cells at the same level/radius, based on your needs, it means it works very approximately and you can only perform &lsquo;circles&rsquo; lookup around the cell you are in.</p></li>

<li><p>The most precise geohash needs 12 bytes storage.</p></li>

<li><p>-90 +90 and +180 -180, -0 +0 are not sides by sides prefixes.</p></li>
</ul>

<h2 id="why-s2">Why S2?</h2>

<p>S2 cells have a level ranging from <code>30</code> ~0.7cm² to <code>0</code> ~85,000,000km².<br />
S2 cells are encoded on an uint64, easy to store.</p>

<p>The main advantage is the <strong>region coverer algorithm</strong>, give it a region and the maximum number of cells you want, S2 will return some cells at <strong>different levels that cover the region you asked for</strong>, remember one cell corresponds to a range lookup you&rsquo;ll have to perform in your database.</p>

<p>The coverage is more accurate it means less read from the DB,  less objects unmarshalling&hellip;</p>

<h2 id="real-world-study">Real world study</h2>

<p>We want to query for objects inside Paris city limits using a rectangle:</p>

<p><img src="https://blog.nobugware.com/img/h5.jpg" alt="h5" title="Geohash using level 5" /><br />
Using level 5 we can&rsquo;t fit the left part of the city.<br />
We could add 3 cells (12 total DB queries ) on the left but most algorithms will zoom out to level 4.</p>

<p><img src="https://blog.nobugware.com/img/h4.jpg" alt="h4" title="Geohash using level 4" /><br />
But now we are querying for the whole region.</p>

<p><img src="https://blog.nobugware.com/img/s2.jpg" alt="s2" title="S2 9 cells" /><br />
Using s2 asking for 9 cells using a rectangle around the city limits.</p>

<p><img src="https://blog.nobugware.com/img/h4vss2.jpg" alt="s2 vs h4" title="Geohash vs s2" /><br />
The zones queried by Geohash in pink and S2 in green.</p>

<h2 id="example-s2-storage">Example S2 storage</h2>

<p>Let&rsquo;s say we want to store every cities in the world and perform a lookup to find the closest cities around, first we need to compute the <code>CellId</code> for each cities.</p>

<pre><code class="language-go">// Compute the CellID for lat, lng
c := s2.CellIDFromLatLng(s2.LatLngFromDegrees(lat, lng))

// store the uint64 value of c to its bigendian binary form
key := make([]byte, 8)
binary.BigEndian.PutUint64(key, uint64(c))
</code></pre>

<p>Big endian is needed to order bytes lexicographically, so we can seek later from one cell to the next closest cell on the Hilbert curve.</p>

<p><code>c</code> is a CellID to the level <code>30</code>.</p>

<p>Now we can store <code>key</code> as the key and a value (a string or msgpack/protobuf) for our city, in the database.</p>

<h2 id="example-s2-lookup">Example S2 lookup</h2>

<p>For the lookup we use the opposite procedure, first looking for one CellID.</p>

<pre><code class="language-go">// citiesInCellID looks for cities inside c
func citiesInCellID(c s2.CellID) {
  // compute min &amp; max limits for c
  bmin := make([]byte, 8)
  bmax := make([]byte, 8)
  binary.BigEndian.PutUint64(bmin, uint64(c.RangeMin()))
  binary.BigEndian.PutUint64(bmax, uint64(c.RangeMax()))

  // perform a range lookup in the DB from bmin key to bmax key, cur is our DB cursor
  var cell s2.CellID
  for k, v := cur.Seek(bmin); k != nil &amp;&amp; bytes.Compare(k, bmax) &lt;= 0; k, v = cur.Next() {
    buf := bytes.NewReader(k)
    binary.Read(buf, binary.BigEndian, &amp;cell)

    // Read back a city
    ll := cell.LatLng()
    lat := float64(ll.Lat.Degrees())
    lng := float64(ll.Lng.Degrees())
    name = string(v)
    fmt.Println(lat, lng, name)
  }
}
</code></pre>

<p>Then compute the CellIDs for the region we want to cover.</p>

<pre><code class="language-go">rect := s2.RectFromLatLng(s2.LatLngFromDegrees(48.99, 1.852))
rect = rect.AddPoint(s2.LatLngFromDegrees(48.68, 2.75))

rc := &amp;s2.RegionCoverer{MaxLevel: 20, MaxCells: 8}
r := s2.Region(rect.CapBound())
covering := rc.Covering(r)

for _, c := range covering {
    citiesInCellID(c)
}
</code></pre>

<p>RegionCoverer will return at most 8 cells (in this case 7 cells: 4 <code>8</code>, 1 <code>7</code>, 1 <code>9</code>, 1 <code>10</code>) that is guaranteed to cover the given region, it means we may have to exclude cities that were <strong>NOT</strong> in our <code>rect</code>, with <code>func (Rect) ContainsLatLng(LatLng)</code>.</p>

<p>Congrats we have a working geo db.</p>

<p>S2 can do more with complex shapes like Polygons and includes a lot of tools to compute distances, areas, intersections between shapes&hellip;</p>

<p>Here is a <a href="https://github.com/akhenakh/CompareGeoHashvsS2/blob/master/h4.json">Github repo for the data &amp; scripts generated for the images</a></p>

                    </div>
                </section>
                
                <h1 class="content-subhead">30 Aug 2015, 18:25</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.nobugware.com/post/2015/leveldb_geohash_golang/" class="post-title">A blazing fast geo database with LevelDB, Go and Geohashes</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Geo" href="https://blog.nobugware.com/categories/geo">Geo</a><a class="post-category post-category-Golang" href="https://blog.nobugware.com/categories/golang">Golang</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>You probably have heard of <a href="https://github.com/google/leveldb">LevelDB</a> it’s a blazing fast key value store (as a library not a daemon), that uses Snappy compression.<br />
There is plenty of usages for it, the API is very simple at least in Go (I will be using <a href="https://github.com/syndtr/goleveldb">Goleveldb</a>).</p>

<p>The key is a <code>[]byte</code> the value is a <code>[]byte</code> so you can “get”, “put” &amp; “delete” that’s it.</p>

<p>I needed a low memory low cpu system that could collect millions of geo data and query over them,  <a href="https://en.wikipedia.org/wiki/Geohash">Geohash</a> has an interesting property you can encode longitude and latitude into a string : <code>f2m616nn</code> this hash represents the lat &amp; long 46.770, -71.304 <a href="http://geohash.org/f2m616nn">f2m616nn</a>, if you shorten the string to <code>f2m61</code> it still refers to the same lat &amp; long but with less precisions <a href="http://geohash.org/f2m61">f2m61</a>.<br />
A 4 digits hash leads to 19545 meters precision, to perfom a lookup around a position you simply query for the 8 adjacent blocks. <a href="http://github.com/TomiHiltunen/geohash-golang">A Geohash library for Go</a>.</p>

<p>Here you would store all of your data points matching a geohash to the same set.<br />
Problem there is no such thing as a set in LevelDB.</p>

<p>But there is a cursor so you can seek to a position then iterate over the next or previous one (byte ordered).<br />
So your data could be stored that way:  4 digits geohash + a uniq id.</p>

<p>Then you can perform proximity lookup by searching for the 8 adjacents hashes from the position your are looking with a precision of 20km, good but not very flexible.</p>

<p>We can have a more generic solution, first we need a key a simple int64 uniq id.</p>

<pre><code class="language-go">// NewKey generates a new key using time prefixed by 'K'
func NewKey() Key {
	return NewKeyWithInt(time.Now().UnixNano())
}

// NewKeyWithInt returns a key prefixed by 'K' with value i
func NewKeyWithInt(id int64) Key {
	key := bytes.NewBufferString(&quot;K&quot;)
	binary.Write(key, binary.BigEndian, id)
	return key.Bytes()
}
</code></pre>

<p>Here we can encode a key with a Unix timestamp so our key is not just a key it’s also an encoded time value, it will be uniq thanks to the nanosecond precision. We are using BigEndian so it can be byte compared: older will be before newer after.</p>

<p>Now about geo encoding our key will be of the form:<br />
<code>G201508282105dhv766K��Ϸ�Y�</code>  (note the end of the key is binary encoded)
You always need a prefix for your keys so you can seek and browse them without running over different keys types, here I have a <code>G</code> as Geo, then a string encoded date prefix, so we can search by date, but we don’t want extra precision here, it would add extra seek to LevelDB, (that’s why we have a modulo of 10 for minutes) then we add a precise geohash and finally our previous uniq id.</p>

<pre><code class="language-go">// NewGeoKey generates a new key using a position &amp; a key
func NewGeoKey(latitude, longitude float64) GeoKey {
	t := time.Now().UTC()
	kint := t.UnixNano()
	kid := NewKeyWithInt(kint)
	// G + string date + geohash 6 + timestamped key 
	// G201508282105dhv766K....
	gk := geohash.EncodeWithPrecision(latitude, longitude, 6)
	ts := t.Format(&quot;2006010215&quot;)

	// modulo 10 to store 10mn interval
	m := t.Minute() - t.Minute()%10
	zkey := []byte(&quot;G&quot; + ts + fmt.Sprintf(&quot;%02d&quot;, m) + gk)
	zkey = append(zkey, kid...)
	return zkey
}
</code></pre>

<p>We can now lookup by flexible date &amp; by flexible proximity like a Redis ZRANGE, you simply need to reverse the process.</p>

<pre><code class="language-go">// GeoKeyPrefix return prefixes to lookup using a GeoKey and timerange
func GeoKeyPrefix(start, stop time.Time) []string {
	var res []string
	d := 10 * time.Minute
	var t time.Time
	t = start
	for {
		if t.After(stop) {
			break
		}

		key := &quot;G&quot; + t.Format(&quot;2006010215&quot;) + fmt.Sprintf(&quot;%02d&quot;, t.Minute()-t.Minute()%10)
		res = append(res, key)
		t = t.Add(d)
	}
	return res
}
</code></pre>

<p>Lookup that way:</p>

<pre><code class="language-go">	d := time.Duration(-10) * time.Minute
	geoPrefixs := GeoKeyPrefix(time.Now().UTC().Add(d), time.Now().UTC())

	// find adjacent hashes in m
	// 1, 5003530
	// 2, 625441
	// 3, 123264
	// 4, 19545
	// 5, 3803
	// 6, 610
	gk := geohash.EncodeWithPrecision(lat, long, 4)
	adjs := geohash.CalculateAllAdjacent(gk)
	adjs = append(adjs, gk)

	// for each adjacent blocks
	for _, gkl := range adjs {

		// for each time range modulo 10
		for _, geoPrefix := range geoPrefixs {
			startGeoKey := []byte(geoPrefix + gkl)
			iter := s.NewIterator(util.BytesPrefix(startGeoKey), nil)

			for iter.Next() {
				log.Println(iter.Value())
			}
			iter.Release()
		}
	}
</code></pre>

<p>It can be optimized, reducing the size of the keys, but it performs extremely well storing around 3 millions geopoints per day, using less than 3% cpu and can received hundreds of queries per second.</p>

<p>Oh did I forget to mention it&rsquo;s running on a Raspberry Pi? :)</p>

<p>I could maybe turn it into a library but it&rsquo;s so simple it&rsquo;s probably useless.<br />
Next blog post: what are those millions points used for?</p>

                    </div>
                </section>
                
            </div>
            

            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="https://blog.nobugware.com/js/all.min.js"></script>
        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-1245966-1', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
