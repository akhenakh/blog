<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="generator" content="Hugo 0.58.1" />
		<title>gRPC Load Balancing inside Kubernetes - Fabrice Aneche</title>

		<meta name="description" content="gRPC Load Balancing inside Kubernetes">


		
	
		




<link rel="stylesheet" href="https://blog.nobugware.com/css/ui.css">

	
		

		<link  rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">

		
	</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="https://blog.nobugware.com/">
				<img class="icon-text" src="https://blog.nobugware.com/img/prev.svg"/>
			</a>
		</li><li><a href="https://blog.nobugware.com/about">About</a></li><li><a href="https://blog.nobugware.com/post/">Post</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
	<header><hgroup id="brand">
	<h1>gRPC Load Balancing inside Kubernetes</h1>
	<h5>
		
		<time datetime="2019-03-11 00:32:43 -0500 -0500">Mar 11, 2019</time>
		<span class="no-print">
			-
				
				<a href="https://blog.nobugware.com/tags/gRPC">gRPC</a>
				
				<a href="https://blog.nobugware.com/tags/Kubernetes">Kubernetes</a>
				
				<a href="https://blog.nobugware.com/tags/Go">Go</a>
				<span>
	</h5>
	
</hgroup>
<hr class="sep" />
</header>
	

<h2 id="context">Context</h2>

<p>I wanted to blog about this for years: how to connect to a Kubernete&rsquo;s loadbalanced service?<br />
How to deal with disconnections/re-connections, maintenance?  What about gRPC specifically?<br />
The answer is heavily connected to the network stack used by Kubernetes, but with the &ldquo;Mesh Network&rdquo; revolution, It&rsquo;s not always clear how it works anymore and what the options are.
<br>
<br></p>

<h2 id="how-it-works">How it works</h2>

<p>First I recommend you to watch this great yet simple video: <a href="https://www.youtube.com/watch?v=6v_BDHIgOY8&amp;feature=youtu.be">Container Networking From Scratch</a>, then the <a href="https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables">Services clusterIP documentation</a>.</p>

<p>To make it simple when you create a Service in Kubernetes, it creates a layer 4 proxy and load balance connections to your pods using iptables, the service endpoint is one IP and a port hiding your real pods.</p>

<h2 id="the-problem">The Problem</h2>

<p>A simple TCP load balancer is good enough for a lot of things especially for HTTP/1.1 since connections are mainly short lived, the clients will try to reconnect often, so it won&rsquo;t stay connected to an old running pod.</p>

<p>But with gRPC over HTTP/2, a TCP connection is maintained open which could lead to issues, like staying connected to a dying pod or unbalancing the cluster because the clients will end on the older pods.</p>

<p>One solution is to use a more advanced proxy that knows about the higher layers.</p>

<p><a href="https://www.envoyproxy.io/">Envoy</a>, <a href="http://www.haproxy.org/">HAProxy</a> and <a href="https://traefik.io/">Traefik</a> are layer 7 reverse proxy load balancers, they know about HTTP/2 (even about gRPC) and can disconnect a backend’s pod without the clients noticing.</p>

<h2 id="edge">Edge</h2>

<p>On the edge of your Kubernetes cluster, you need a public IP, provided by your cloud provider via <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">the <code>Ingress</code> directive</a> it will expose your internal service.</p>

<p>To further control your request routing you need <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">an Ingress Controller</a>.<br />
It&rsquo;s a reverse proxy that knows about the Kubernetes clusters and can direct the requests to the right place.
<a href="https://www.envoyproxy.io/">Envoy</a>, <a href="http://www.haproxy.org/">HAProxy</a> and <a href="https://traefik.io/">Traefik</a> can act as Ingress Controllers.</p>

<h2 id="internal-services-service-mesh">Internal Services &amp; Service Mesh</h2>

<p>In a Micro-services environment, most if not all your micro-services will also be clients to others micro-services.</p>

<p><a href="https://istio.io/">Istio</a>, a &ldquo;Mesh Network&rdquo; solution, use <a href="https://www.envoyproxy.io/">Envoy</a> as a <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">sidecar</a>. This sidecar is configured from a central place (control plane) and makes each micro-service talking to each other through Envoy.</p>

<p>This way the client does not need to know about all the topology.</p>

<p>That&rsquo;s great but in a controlled environment (yours), where you control all the clients, sending all the traffic through a proxy is not always necessary.</p>

<h2 id="client-load-balancing">Client Load Balancing</h2>

<p>In Kubernetes you can create a <a href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services">headless service</a>; where there are no load balanced single endpoints anymore, the service pods are directly exposed, Kubernetes DNS will return all of them.</p>

<p>Here is an example service called <code>geoipd</code> scaled to 3.</p>

<pre><code>Name:      geoipd
Address 1: 172.17.0.18 172-17-0-18.geoipd.default.svc.cluster.local
Address 2: 172.17.0.21 172-17-0-21.geoipd.default.svc.cluster.local
Address 3: 172.17.0.9 172-17-0-9.geoipd.default.svc.cluster.local
</code></pre>

<p>It&rsquo;s up to your client to connect them all and load balance the connections.</p>

<p>In Go gRPC client side, a simple <code>dns:///</code> notation will fetch the entries for you, then the <a href="https://godoc.org/github.com/grpc/grpc-go/balancer/roundrobin">roundrobin package</a> will handle load balancing.</p>

<pre><code class="language-Go">conn, err := grpc.Dial(
    &quot;dns:///geoip:9200&quot;,
    grpc.WithBalancerName(roundrobin.Name),
)
</code></pre>

<p>This may sound like a good solution but it is not: the default refresh frequency is 30 minutes, meaning whenever you add new pods, it can take up to 30 minutes for them to start getting traffic!
You can lower this problem by tweaking <code>MaxConnectionAge</code> on the gRPC server:</p>

<pre><code class="language-Go">gsrv := grpc.NewServer(
    // MaxConnectionAge is just to avoid long connection, to facilitate load balancing
    // MaxConnectionAgeGrace will torn them, default to infinity
    grpc.KeepaliveParams(keepalive.ServerParameters{MaxConnectionAge: 2 * time.Minute}),
)
</code></pre>

<p>Even if you could refresh the list more often you wouldn&rsquo;t know about pod eviction fast enough and you’d miss some traffic.</p>

<p>There is a nicer solution, implementing the gRPC client resolver for Kubernetes, talking to the Kubernetes API to get the endpoints and watch them constantly, this is exactly what <a href="https://github.com/sercand/kuberesolver">Kuberesolver</a> does.</p>

<pre><code class="language-Go">// Register kuberesolver to grpc
kuberesolver.RegisterInCluster()

conn, err := grpc.Dial(
    &quot;kubernetes:///geoipd:9200&quot;,
    grpc.WithBalancerName(roundrobin.Name),
)
</code></pre>

<p>By using <code>kubernetes</code> schema you tell kuberesolver to fetch and watch the endpoints for the <code>geoipd</code> service.</p>

<p>For this to work the pod must have <code>GET</code> and <code>WATCH</code> access to <code>endpoints</code> using a role:</p>

<pre><code>kubectl create role pod-reader-role --verb=get --verb=watch --resource=endpoints,services 
kubectl create sa pod-reader-sa 
kubectl create rolebinding pod-reader-rb --role=pod-reader-role --serviceaccount=default:pod-reader-sa 
</code></pre>

<p>Redeploy your app (the client) with the service account:</p>

<pre><code class="language-yaml">spec:
  serviceAccountName: pod-reader-sa
</code></pre>

<p>Deploy, scale up, scale down, kill your pods, your client is still sending traffic to a living pod !</p>

<p>I&rsquo;m surprised it&rsquo;s not mentioned more often, client load balancing did the job for years, the same apply inside Kubernetes environment.<br />
It is fine for small to medium projects and can deal with a lot of traffic, this will do it for many of you unless if you are Netflix sized&hellip;</p>

<h2 id="conclusion">Conclusion</h2>

<p>Load-balancing proxies are great tools, especially useful on the edge of your platform. &ldquo;Mesh Network&rdquo; solutions are nice additions to our tool set, but the cost of operating and debugging a full mesh network could be really expensive and overkill in some situations, while a client load balancing solution is simple and easy to grasp.</p>

<p>Thanks to <a href="https://github.com/prune998">Prune</a> who helped me with this post, and to <a href="https://twitter.com/robteix">Robteix</a> &amp; <a href="https://twitter.com/diligiant">diligiant</a> for reviewing.</p>

</article>
<nav class="no-print post-nav">

	<a class="prev-post" href="https://blog.nobugware.com/post/2019/traefik_load_balancing_grpc_services_trace_propagation/">
		<img class="icon-text" src="https://blog.nobugware.com/img/prev.svg"/>Traefik gRPC Load Balancing and Traces Propagation</a>


	<a class="next-post" href="https://blog.nobugware.com/post/2019/deploying-a-website-with-caddy-git-and-kubernetes/">Deploying a website with Caddy, Git and Kubernetes<img class="icon-text" src="https://blog.nobugware.com/img/next.svg"/>
	</a>

</nav>


<section id="related">
  <h4>See Also</h4>
  <ul>
    
  	<li><a href="https://blog.nobugware.com/post/2019/traefik_load_balancing_grpc_services_trace_propagation/">Traefik gRPC Load Balancing and Traces Propagation</a></li>
  	
  	<li><a href="https://blog.nobugware.com/post/2019/kubernetes_quick_development_setup_minikube_prometheus_grafana/">Kubernetes Quick Setup with Prometheus, Grafana &amp; Jaeger</a></li>
  	
  	<li><a href="https://blog.nobugware.com/post/2018/wasm_go_s2_javascript/">Wasm with Go to build an S2 cover map viewer</a></li>
  	
  </ul>
</section>




			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				

<a href="https://github.com/akhenakh/"><img class="icon-social" src="https://blog.nobugware.com/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/akhenakh"><img class="icon-social" src="https://blog.nobugware.com/img/twitter.svg" alt="Twitter"/></a>

<a href="https://blog.nobugware.com/index.xml" target="_blank"><img class="icon-social" src="https://blog.nobugware.com/img/feed.svg" alt="Feed"></a>

				<p>
					
					Theme used: <a href="https://github.com/yursan9/manis-hugo-theme">Manis</a><br>
					
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="https://blog.nobugware.com/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
	</body>
</html>

